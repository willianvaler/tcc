<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Sat Jan 21 10:29:50 PST 2012 -->
<TITLE>
: Class  Node
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY onLoad="top.document.cookie='lastClass=Node';" BGCOLOR="white">

<table CLASS=pageHeader RULES=none BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=5><tr><td NOWRAP width=26><IMG ALIGN=LEFT BORDER=0 width=20 SRC="../../Norsys_blueSquares.gif"></td><td NOWRAP><FONT FACE="Arial" COLOR="BLUE"><b>NORSYS SOFTWARE &copy; 2012</b></FONT></td><td NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;<FONT FACE="Arial" COLOR="BLUE"><b>NETICA API</b></FONT>&nbsp;&nbsp;&nbsp;&nbsp;</td><td NOWRAP ALIGN="right"><FONT FACE="Arial" COLOR="BLUE"><b>JAVA &nbsp VERSION &nbsp 5.04</b></FONT>&nbsp</td></tr></table><hr><!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../norsys/netica/NetTester.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../norsys/netica/NodeList.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Node.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
norsys.netica</FONT>
<BR>
Class  Node</H2>
<PRE>
java.lang.Object
  |
  +--<A HREF="../../norsys/netica/General.html">norsys.netica.General</A>
        |
        +--<B>norsys.netica.Node</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../norsys/netica/NeticaListener.html">NeticaListener</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>Node</B><DT>extends <A HREF="../../norsys/netica/General.html">General</A></DL>

<P>
A node (object which represents a variable) in a Net (Bayesian belief network or decision network).
<P>
<DL>
<DT><B>Since: </B><DD>All versions</DD>
<DT><B>Version: </B><DD>5.04 - January 21, 2012</DD>
</DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#CONSTANT_NODE">CONSTANT_NODE</A></B></CODE>

<BR>
<p>The value of this node is considered unchanging until the net is rebuilt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#CONTINUOUS_TYPE">CONTINUOUS_TYPE</A></B></CODE>

<BR>
<p>Node is for a continuous (analog) variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#DECISION_NODE">DECISION_NODE</A></B></CODE>

<BR>
<p>This node is for a variable that can be controlled by the agent (the "decision" node of an influence diagram).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#DISCONNECTED_NODE">DISCONNECTED_NODE</A></B></CODE>

<BR>
<p>This node is just a placeholder for a disconnected link, to indicate the type of parent it requires.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#DISCRETE_TYPE">DISCRETE_TYPE</A></B></CODE>

<BR>
<p>Node is for a discrete (digital) variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#EVERY_STATE">EVERY_STATE</A></B></CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use State.EVERY_STATE</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#IMPOSS_STATE">IMPOSS_STATE</A></B></CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use State.IMPOSS_STATE</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#LIKELIHOOD_FINDING">LIKELIHOOD_FINDING</A></B></CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#LIKELIHOOD_VALUE"><CODE>Value.LIKELIHOOD_VALUE</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#NATURE_NODE">NATURE_NODE</A></B></CODE>

<BR>
<p>The value of this node is determined by nature (also known as a "chance" or "deterministic" node).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#NEGATIVE_FINDING">NEGATIVE_FINDING</A></B></CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#STATE_NOT_VALUE"><CODE>Value.STATE_NOT_VALUE</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#NO_FINDING">NO_FINDING</A></B></CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#NO_VALUE"><CODE>Value.NO_VALUE</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#TEXT_TYPE">TEXT_TYPE</A></B></CODE>

<BR>
<p>A future type of Node, one used for holding or rendering text.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#UNDEF_STATE">UNDEF_STATE</A></B></CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use State.UNDEF_STATE</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#UTILITY_NODE">UTILITY_NODE</A></B></CODE>

<BR>
<p>This node specifies the agent's desires; its expected value will be maximized.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_norsys.netica.General"></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class norsys.netica.<A HREF="../../norsys/netica/General.html">General</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../norsys/netica/General.html#NAME_MAX">NAME_MAX</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#Node()">Node</A></B>()</CODE>

<BR>
<p>Default constructor - do not call this constructor directly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#Node(java.lang.String, int, norsys.netica.Net)">Node</A></B>(java.lang.String&nbsp;name,
     int&nbsp;numStates,
     <A HREF="../../norsys/netica/Net.html">Net</A>&nbsp;net)</CODE>

<BR>
<p>Creates and returns a new node for <span CLASS="paramNm">net</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#Node(java.lang.String, java.lang.String, norsys.netica.Net)">Node</A></B>(java.lang.String&nbsp;name,
     java.lang.String&nbsp;stateNames,
     <A HREF="../../norsys/netica/Net.html">Net</A>&nbsp;net)</CODE>

<BR>
<p>Construct a node with the given name and state names, for the given Net.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../norsys/netica/Value.html">Value</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#action()">action</A></B>()</CODE>

<BR>
<p>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A></B>(<A HREF="../../norsys/netica/Node.html">Node</A>&nbsp;parentNode)</CODE>

<BR>
<p>Adds a link from <span CLASS="paramNm">parentNode</span> to this node, and returns the index of the added link.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#addStates(int, java.lang.String, int, double)">addStates</A></B>(int&nbsp;firstState,
          java.lang.String&nbsp;stateNames,
          int&nbsp;numStates,
          double&nbsp;cptFill)</CODE>

<BR>
<p>
  Adds one or more states to this node, inserting them into the existing states.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#addToNodeset(java.lang.String)">addToNodeset</A></B>(java.lang.String&nbsp;nodeset)</CODE>

<BR>
<p>Adds this node to the node-set named <span CLASS="paramNm">nodeset</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#calcState()">calcState</A></B>()</CODE>

<BR>
<p>Returns the discrete finding entered for this node if one has been entered, or the state calculated from its neighbors if that can be done deterministically (e.g., by equation or function table), or else <A HREF="../../norsys/netica/State.html#UNDEF_STATE"> UNDEF_STATE</A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#calcValue()">calcValue</A></B>()</CODE>

<BR>
<p>Returns the real-valued finding entered for this node if one has been entered, or the real value calculated from its neighbors if that can be done deterministically (e.g., by equation or function table), or else <A HREF="../../norsys/netica/Environ.html#UNDEF_DBL"> UNDEF_DBL</A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#delete()">delete</A></B>()</CODE>

<BR>
<p>Removes this node from its net, and frees all resources (e.g., memory) it was using.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#deleteLink(int)">deleteLink</A></B>(int&nbsp;parentLinkIndex)</CODE>

<BR>
<p>Delete the link entering this node from the given parent node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#deleteTables()">deleteTables</A></B>()</CODE>

<BR>
<p>
  Deletes this node's function table, its CPT table, and its experience table.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#enterFinding(int)">enterFinding</A></B>(int&nbsp;stateIndex)</CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#enterState(int)"><CODE>finding().enterState (stateIndex)</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#enterFinding(java.lang.String)">enterFinding</A></B>(java.lang.String&nbsp;stateName)</CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#enterState(java.lang.String)"><CODE>finding().enterState (stateName)</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#enterFindingNot(int)">enterFindingNot</A></B>(int&nbsp;stateIndex)</CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#enterStateNot(int)"><CODE>finding().enterStateNot (stateIndex)</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#enterLikelihood(float[])">enterLikelihood</A></B>(float[]&nbsp;likelihood)</CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#enterLikelihood(float[])"><CODE>finding().enterLikelihood (likelihood)</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#enterValue(double)">enterValue</A></B>(double&nbsp;value)</CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#enterReal(double)"><CODE>finding().enterReal (value)</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#equationToTable(int, boolean, boolean)">equationToTable</A></B>(int&nbsp;numSamples,
                boolean&nbsp;includeSamplingUncertainty,
                boolean&nbsp;addExisting)</CODE>

<BR>
<p>Builds the CPT for this node based on the equation that has been associated with it (see&nbsp;<A HREF="../../norsys/netica/Node.html#setEquation(java.lang.String)">setEquation</A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#fadeCPTable(double)">fadeCPTable</A></B>(double&nbsp;degree)</CODE>

<BR>
<p>Smoothes the conditional probabilities (CPT) of this node to indicate greater uncertainty, which accounts for the idea that the world may have changed a little since they were last learned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#finalize()">finalize</A></B>()</CODE>

<BR>
<p>Called by the garbage collector, when this node can no longer be referenced.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../norsys/netica/Value.html">Value</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#finding()">finding</A></B>()</CODE>

<BR>
<p>Returns the Value object holding this node's finding (aka, "evidence") information.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getBelief(java.lang.String)">getBelief</A></B>(java.lang.String&nbsp;stateName)</CODE>

<BR>
<p>Gets the belief that this node is in the given named state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getBeliefs()">getBeliefs</A></B>()</CODE>

<BR>
<p>
  Returns a belief vector indicating the current probability for each state of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../norsys/netica/NodeList.html">NodeList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getChildren()">getChildren</A></B>()</CODE>

<BR>
<p>Returns a list of the children of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getConstructorClass()">getConstructorClass</A></B>()</CODE>

<BR>
<p>Retrieves the classname of the class that Netica-J uses when constructing a Node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getCPTable(float[])">getCPTable</A></B>(float[]&nbsp;cpTable)</CODE>

<BR>
<p>Retrieves the entire CPTable of this node as a 1-D array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getCPTable(int[], float[])">getCPTable</A></B>(int[]&nbsp;parentStates,
           float[]&nbsp;cpTable)</CODE>

<BR>
<p>Returns the conditional probabilities of this node, given that its parents are in the states indicated by the <span CLASS="paramNm">parentStates</span> vector, by looking them up in the node's CPT table.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getCPTable(java.lang.String, float[])">getCPTable</A></B>(java.lang.String&nbsp;parentStatesStr,
           float[]&nbsp;cpTable)</CODE>

<BR>
<p>This does the same as <A HREF="../../norsys/netica/Node.html#getCPTable(int[], float[])">getCPTable(int[], float[])</A> except that it takes the parent states as a string rather than as an integer array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getEquation()">getEquation</A></B>()</CODE>

<BR>
<p>Returns the equation associated with this node, or the empty string (rather than <span CLASS="reservedWord">null</span>), if this node does not have an equation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getExpectedUtils()">getExpectedUtils</A></B>()</CODE>

<BR>
<p>Returns a vector providing the expected utility of each choice in a decision node, considering findings currently entered.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getExpectedValue(double[])">getExpectedValue</A></B>(double[]&nbsp;moments)</CODE>

<BR>
<p>Returns the expected real value of this node, based on the current beliefs for this node, and if <span CLASS="paramNm">moments</span> is non-<span CLASS="reservedWord">null</span>, <span CLASS="paramNm">moments</span> will be filled with the moments as well.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getExperTable(int[], double[])">getExperTable</A></B>(int[]&nbsp;parentStates,
              double[]&nbsp;experTable)</CODE>

<BR>
<p>Given <span CLASS="paramNm">parentStates</span>, a vector of states for the parents of this node, this returns the "experience" of the node for the situation described by the parent states.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getFinding()">getFinding</A></B>()</CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#getState()"><CODE>finding().getState()</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getInputIndex(java.lang.String)">getInputIndex</A></B>(java.lang.String&nbsp;linkName)</CODE>

<BR>
<p>Returns the link index number of the link whose name is <span CLASS="paramNm">linkName</span>, or -1 if there isn't one with that name (case sensitive comparison).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getInputName(int)">getInputName</A></B>(int&nbsp;inputIndex)</CODE>

<BR>
<p>Gets the name of this node's input (i.e., link) identified by the given index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getKind()">getKind</A></B>()</CODE>

<BR>
<p>Returns whether this node is a nature, decision, utility or constant node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getLevels()">getLevels</A></B>()</CODE>

<BR>
<p>Returns the list of numbers used to enable a continuous node to act discrete, or enables a discrete node to provide real-valued numbers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getLikelihood()">getLikelihood</A></B>()</CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#getLikelihood(float[])"><CODE>finding().getLikelihood(null)</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../norsys/netica/Net.html">Net</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getNet()">getNet</A></B>()</CODE>

<BR>
<p>Returns the net that this node is part of.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A></B>()</CODE>

<BR>
<p>Returns the number of states that this node can take on, or zero if this node is a continuous node that hasn't been discretized.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../norsys/netica/NodeList.html">NodeList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getParents()">getParents</A></B>()</CODE>

<BR>
<p>Returns a list of the parents of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getRealFuncTable(int[], double[])">getRealFuncTable</A></B>(int[]&nbsp;parentStates,
                 double[]&nbsp;realTable)</CODE>

<BR>
<p>Gets the real value of this node as a function of its parent nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getRelatedNodes(norsys.netica.NodeList, java.lang.String)">getRelatedNodes</A></B>(<A HREF="../../norsys/netica/NodeList.html">NodeList</A>&nbsp;relatedNodes,
                java.lang.String&nbsp;relation)</CODE>

<BR>
<p>Finds all the Nodes that bear the relationship <span CLASS="paramNm">relation</span> with this node and puts them in <span CLASS="paramNm">relatedNodes</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getStateFuncTable(int[], int[])">getStateFuncTable</A></B>(int[]&nbsp;parentStates,
                  int[]&nbsp;stateTable)</CODE>

<BR>
<p>Gets the state value of this node as a function of its parent nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getType()">getType</A></B>()</CODE>

<BR>
<p>Returns <A HREF="../../norsys/netica/Node.html#DISCRETE_TYPE"> DISCRETE_TYPE</A> if the variable corresponding to this node is discrete (digital), and <A HREF="../../norsys/netica/Node.html#CONTINUOUS_TYPE"> CONTINUOUS_TYPE</A> if it is continuous (analog).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#getValueEntered()">getValueEntered</A></B>()</CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#getReal()"><CODE>finding().getReal()</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#hasTable(boolean[])">hasTable</A></B>(boolean[]&nbsp;complete)</CODE>

<BR>
<p>Returns <span CLASS="reservedWord">true</span> if this node has a function table or a CPT table, otherwise <span CLASS="reservedWord">false</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#isBeliefUpdated()">isBeliefUpdated</A></B>()</CODE>

<BR>
<p>Whether the beliefs for this node have already been calculated (by belief propagation).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#isDeterministic()">isDeterministic</A></B>()</CODE>

<BR>
<p>Whether the value of this node, given its parents, is deterministic (versus probabilistic).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#isInNodeset(java.lang.String)">isInNodeset</A></B>(java.lang.String&nbsp;nodeset)</CODE>

<BR>
<p>Returns whether this node is a member of <span CLASS="paramNm">nodeset</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#isRelated(java.lang.String, norsys.netica.Node)">isRelated</A></B>(java.lang.String&nbsp;relation,
          <A HREF="../../norsys/netica/Node.html">Node</A>&nbsp;otherNode)</CODE>

<BR>
<p>
  Tests whether this node bears the relationship <span CLASS="paramNm">relation</span> with <span CLASS="paramNm">otherNode</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#parentStatesToIndexes(java.lang.String)">parentStatesToIndexes</A></B>(java.lang.String&nbsp;parentStateNamesStr)</CODE>

<BR>
<p>Utility to convert a comma and/or space delimited string of parent state names for this node to an array of state indexes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#removeFromNodeset(java.lang.String)">removeFromNodeset</A></B>(java.lang.String&nbsp;nodeset)</CODE>

<BR>
<p>Removes this node from the node-set named <span CLASS="paramNm">nodeset</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#reorderStates(int[])">reorderStates</A></B>(int[]&nbsp;newOrder)</CODE>

<BR>
<p>Rearranges the order of the states so that state <i>i</i> is moved to position
  <span CLASS="paramNm">newOrder</span><i>[i]</i>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#retractFindings()">retractFindings</A></B>()</CODE>

<BR>
<p><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#clear()"><CODE>finding().clear()</CODE></A> instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#reverseLink(norsys.netica.Node)">reverseLink</A></B>(<A HREF="../../norsys/netica/Node.html">Node</A>&nbsp;parentNode)</CODE>

<BR>
<p>Reverses the link from <span CLASS="paramNm">parentNode</span> to this child node, so that instead it goes from this node to <span CLASS="paramNm">parentNode</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setConstructorClass(java.lang.String)">setConstructorClass</A></B>(java.lang.String&nbsp;nodeClassNm)</CODE>

<BR>
<p>Sets the classname that Netica-J will use to independently construct Nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setCPTable(float[])">setCPTable</A></B>(float[]&nbsp;cpTable)</CODE>

<BR>
<p>Sets the entire CPTable of this node in one call.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A></B>(int[]&nbsp;parentStates,
           float[]&nbsp;cpTable)</CODE>

<BR>
<p>Sets the probabilities for each state of this node, conditioned on its parent nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setCPTable(java.lang.String, float[])">setCPTable</A></B>(java.lang.String&nbsp;parentStateNames,
           float[]&nbsp;cpTable)</CODE>

<BR>
<p>This does the same as <A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable(int[], float[])</A> except that it takes the parent states as a string rather than as an integer array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setEquation(java.lang.String)">setEquation</A></B>(java.lang.String&nbsp;eqn)</CODE>

<BR>
<p>Sets the equation giving the probability of this node conditioned on its parent nodes, or the value of this node as a function of its parents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setExperTable(double)">setExperTable</A></B>(double&nbsp;experience)</CODE>

<BR>
<p>Sets the experience of this node as a function of its parent nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setExperTable(int[], double)">setExperTable</A></B>(int[]&nbsp;parentStates,
              double&nbsp;experience)</CODE>

<BR>
<p>Sets the experience of this node as a function of its parent nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setInputDelay(int, int, java.lang.String)">setInputDelay</A></B>(int&nbsp;linkIndex,
              int&nbsp;dimension,
              java.lang.String&nbsp;delay)</CODE>

<BR>
<p>Sets the "time" delay for a link of this dynamic Bayes net (DBN) to <span CLASS="paramNm">delay</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setInputName(int, java.lang.String)">setInputName</A></B>(int&nbsp;inputIndex,
             java.lang.String&nbsp;inputName)</CODE>

<BR>
<p>Sets the name of this node's input (i.e., link).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setKind(int)">setKind</A></B>(int&nbsp;kind)</CODE>

<BR>
<p>Sets whether this node is a nature, decision, utility or constant node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A></B>(double[]&nbsp;levels)</CODE>

<BR>
<p>Sets the levels list of this node to <span CLASS="paramNm">levels</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setPersistance(int, java.lang.String)">setPersistance</A></B>(int&nbsp;dimension,
               java.lang.String&nbsp;persistance)</CODE>

<BR>
<p>Sets the time persistance for a node of a dynamic Bayes net (DBN), which is the maximum time it should hold its value before taking on a new one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setRealFuncTable(int[], double)">setRealFuncTable</A></B>(int[]&nbsp;parentStates,
                 double&nbsp;funcValue)</CODE>

<BR>
<p>Sets the real value of this (continuous) deterministic node as a function of its parent nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setStateFuncTable(int[], int)">setStateFuncTable</A></B>(int[]&nbsp;parentStates,
                  int&nbsp;funcState)</CODE>

<BR>
<p>Sets the state value of this (discrete or discretized) deterministic node as a function of its parent nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#setStateNames(java.lang.String)">setStateNames</A></B>(java.lang.String&nbsp;names)</CODE>

<BR>
<p>Names the states of this node using the list of names <span CLASS="paramNm">names</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../norsys/netica/State.html">State</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#state(int)">state</A></B>(int&nbsp;stateIndex)</CODE>

<BR>
<p>Returns a state of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../norsys/netica/State.html">State</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#state(java.lang.String)">state</A></B>(java.lang.String&nbsp;stateName)</CODE>

<BR>
<p>Returns a state of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#switchParent(int, norsys.netica.Node)">switchParent</A></B>(int&nbsp;linkIndex,
             <A HREF="../../norsys/netica/Node.html">Node</A>&nbsp;newParent)</CODE>

<BR>
<p>Switches the parent of the identified link with <span CLASS="paramNm">newParent</span>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../norsys/netica/VisualNode.html">VisualNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../norsys/netica/Node.html#visual()">visual</A></B>()</CODE>

<BR>
<p>Return the <span CLASS="classType"> VisualNode</span> object which can be used to control the visual display of this node in Netica Application.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_norsys.netica.General"></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class norsys.netica.<A HREF="../../norsys/netica/General.html">General</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../norsys/netica/General.html#addListener(norsys.netica.NeticaListener)">addListener</A>, <A HREF="../../norsys/netica/General.html#eventOccurred(norsys.netica.NeticaEvent)">eventOccurred</A>, <A HREF="../../norsys/netica/General.html#getComment()">getComment</A>, <A HREF="../../norsys/netica/General.html#getEnviron()">getEnviron</A>, <A HREF="../../norsys/netica/General.html#getLabel()">getLabel</A>, <A HREF="../../norsys/netica/General.html#getLabel(java.lang.String)">getLabel</A>, <A HREF="../../norsys/netica/General.html#getName()">getName</A>, <A HREF="../../norsys/netica/General.html#getTitle()">getTitle</A>, <A HREF="../../norsys/netica/General.html#removeListener(norsys.netica.NeticaListener)">removeListener</A>, <A HREF="../../norsys/netica/General.html#setComment(java.lang.String)">setComment</A>, <A HREF="../../norsys/netica/General.html#setName(java.lang.String)">setName</A>, <A HREF="../../norsys/netica/General.html#setTitle(java.lang.String)">setTitle</A>, <A HREF="../../norsys/netica/General.html#toString()">toString</A>, <A HREF="../../norsys/netica/General.html#user()">user</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="CONTINUOUS_TYPE"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>CONTINUOUS_TYPE</span>&nbsp;</td></tr></table></div>
<DL>
<DD>Node is for a continuous (analog) variable.  Opposite of <A HREF="../../norsys/netica/Node.html#DISCRETE_TYPE"> DISCRETE_TYPE</A>.  See <A HREF="../../norsys/netica/Node.html#getType()">getType</A>.
 <br><br></DL>
<HR>

<A NAME="DISCRETE_TYPE"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>DISCRETE_TYPE</span>&nbsp;</td></tr></table></div>
<DL>
<DD>Node is for a discrete (digital) variable. Opposite of <A HREF="../../norsys/netica/Node.html#CONTINUOUS_TYPE"> CONTINUOUS_TYPE</A>.  See <A HREF="../../norsys/netica/Node.html#getType()">getType</A>.
 <br><br></DL>
<HR>

<A NAME="TEXT_TYPE"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>TEXT_TYPE</span>&nbsp;</td></tr></table></div>
<DL>
<DD>A future type of Node, one used for holding or rendering text.  Not currently used.
 <br><br></DL>
<HR>

<A NAME="CONSTANT_NODE"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>CONSTANT_NODE</span>&nbsp;</td></tr></table></div>
<DL>
<DD>The value of this node is considered unchanging until the net is rebuilt.  See <A HREF="../../norsys/netica/Node.html#getKind()">getKind</A>.
 <br><br></DL>
<HR>

<A NAME="DECISION_NODE"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>DECISION_NODE</span>&nbsp;</td></tr></table></div>
<DL>
<DD>This node is for a variable that can be controlled by the agent (the "decision" node of an influence diagram).  See <A HREF="../../norsys/netica/Node.html#getKind()">getKind</A>.
 <br><br></DL>
<HR>

<A NAME="DISCONNECTED_NODE"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>DISCONNECTED_NODE</span>&nbsp;</td></tr></table></div>
<DL>
<DD>This node is just a placeholder for a disconnected link, to indicate the type of parent it requires.  See <A HREF="../../norsys/netica/Node.html#getKind()">getKind</A>.
 <br><br></DL>
<HR>

<A NAME="NATURE_NODE"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>NATURE_NODE</span>&nbsp;</td></tr></table></div>
<DL>
<DD>The value of this node is determined by nature (also known as a "chance" or "deterministic" node).   This is the most common kind of node.  See <A HREF="../../norsys/netica/Node.html#getKind()">getKind</A>.
 <br><br></DL>
<HR>

<A NAME="UTILITY_NODE"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>UTILITY_NODE</span>&nbsp;</td></tr></table></div>
<DL>
<DD>This node specifies the agent's desires; its expected value will be maximized. <p>This is a "value" node of an influence diagram.  See <A HREF="../../norsys/netica/Node.html#getKind()">getKind</A>.
 <br><br></DL>
<HR>

<A NAME="EVERY_STATE"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>EVERY_STATE</span>&nbsp;</td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use State.EVERY_STATE</I>
<P>
</DL>
<HR>

<A NAME="IMPOSS_STATE"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>IMPOSS_STATE</span>&nbsp;</td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use State.IMPOSS_STATE</I>
<P>
</DL>
<HR>

<A NAME="UNDEF_STATE"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>UNDEF_STATE</span>&nbsp;</td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use State.UNDEF_STATE</I>
<P>
</DL>
<HR>

<A NAME="LIKELIHOOD_FINDING"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>LIKELIHOOD_FINDING</span>&nbsp;</td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#LIKELIHOOD_VALUE"><CODE>Value.LIKELIHOOD_VALUE</CODE></A> instead.</I>
<P>
</DL>
<HR>

<A NAME="NEGATIVE_FINDING"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>NEGATIVE_FINDING</span>&nbsp;</td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#STATE_NOT_VALUE"><CODE>Value.STATE_NOT_VALUE</CODE></A> instead.</I>
<P>
</DL>
<HR>

<A NAME="NO_FINDING"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;final&nbsp;<span CLASS=PTFntype> int</span>&nbsp;<span CLASS=PTFnName>NO_FINDING</span>&nbsp;</td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#NO_VALUE"><CODE>Value.NO_VALUE</CODE></A> instead.</I>
<P>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Node(java.lang.String, int, norsys.netica.Net)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFnName>Node</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>name</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>numStates</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;<A CLASS=APT HREF="../../norsys/netica/Net.html">Net</A></span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>net</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
     throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Creates and returns a new node for <span CLASS="paramNm">net</span>.
 <p>If the node is for a discrete variable, pass the number of states it has for <span CLASS="paramNm">numStates</span>.
 <p>If the node is for a variable which is continuous in the real world, pass 0 for <span CLASS="paramNm">numStates</span>, even if you plan to later discretize it to a certain number of states (see&nbsp;<A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A> for more details).
 <p><span CLASS="paramNm">name</span> will be the name of the new node.  It must be different from the names of all other nodes in <span CLASS="paramNm">net</span> (by case-sensitive comparison), and it must be a legal IDname, which means it  must have <A HREF="../../norsys/netica/General.html#NAME_MAX"> NAME_MAX</A> (30) or fewer characters, all of which are letters, digits or underscores, and it must start with a letter.  If name ends with an asterisk (*), then Netica will replace the * with an integer to make a unique name for the node; you can discover what name was picked using <A HREF="../../norsys/netica/Node.html#getName(java.lang.String)">getName</A> after the node is formed.
 <p>The node will start off as a nature node (kind = <A HREF="../../norsys/netica/Node.html#NATURE_NODE"> NATURE_NODE</A>), but it may be changed by calling <A HREF="../../norsys/netica/Node.html#setKind(int)">setKind</A>.
 
 <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">name</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The name of this node.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">numStates</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The number of states for this node, if this is a discrete node.  If it is continuous,
 		  then supply 0, even if you plan to later discretize it to a certain number of states.
 		  See <A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A>.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm"><a href="Net.html">Net</a></span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">net</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The net in which the new node is placed.</td></tr></table><br><b>Version:</b><br><div CLASS="version">In the C Version of the API, this function is named <b>NewNode_bn</b>.
 </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#delete()">delete</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">(reverse operation)  Removes the node from its net and frees memory it uses</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#copyNodes(norsys.netica.NodeList)">copyNodes</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Creates nodes by duplicating them, even from another net</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setKind(int)">setKind</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Set what kind of node it is (nature, decision, utility, etc.)</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The way to set the number of states if the node is for a continuous variable being discretized</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/General.html#setName(java.lang.String)"><CODE>setName</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Later change the name</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/General.html#setTitle(java.lang.String)"><CODE>setTitle</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Label the node without the IDname restriction</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getType()">getType</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Determine if it was created as a continuous variable node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieve <span CLASS="paramNm">numStates</span></td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/General.html#getName()"><CODE>getName</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieve name</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Link the new node with others</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#Net(norsys.netica.Environ)">Net</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Create a net for adding nodes</td></tr></table><br><b>Example:</b>
 <pre CLASS="example"><div CLASS=desc>See <A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A> for creating a discretized node for a continuous variable.</div>
 // Here is how you might make a new node with the 2 states
 // "true" and "false" using this constructor.
 Node node = New Node ("n1", 2, net);
 node.setStateNames("true, false");</pre></DL>
<HR>

<A NAME="Node(java.lang.String, java.lang.String, norsys.netica.Net)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFnName>Node</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>name</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>stateNames</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;<A CLASS=APT HREF="../../norsys/netica/Net.html">Net</A></span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>net</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
     throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Construct a node with the given name and state names, for the given Net.
 <p>A convenience constructor, identical to <A HREF="../../norsys/netica/Node.html#Node(java.lang.String, int, norsys.netica.Net)">Node(String, int, Net)</A>, only where you can assign the nodes's state names immediately, rather than having to call <A HREF="../../norsys/netica/Node.html#setStateNames(java.lang.String)">setStateNames</A> separately.
 <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">name</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The name of this node.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">names</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">A string of unique stateNames, each separated by a comma and/or space.  Each stateName can be no larger than <A HREF="../../norsys/netica/General.html#NAME_MAX"> NAME_MAX</A> (30) chararacters.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm"><a href="Net.html">Net</a></span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentNet</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The net in which the new node will be placed.</td></tr></table><br><b>Example:</b>
 <pre CLASS="example">
 // Here is how you might make a new node with the 2 states "true" and "false".
 Node node = New Node ("n1", "true, false", net);</pre></DL>
<HR>

<A NAME="Node()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFnName>Node</span>&nbsp;(&nbsp;)
     throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Default constructor - do not call this constructor directly.  The only reason it has public access is that this is required should you wish to subclass this class, since in that case you will need to supply a default public constructor for Netica to use in constructing instances of your special type of Node.
 <br><br></DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="action()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype><A CLASS=APT HREF="../../norsys/netica/Value.html">Value</A></span>&nbsp;<span CLASS=PTFnName>action</span>&nbsp;(&nbsp;)</td></tr></table></div>
<DL>
</DL>
<HR>

<A NAME="addLink(norsys.netica.Node)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>int</span>&nbsp;<span CLASS=PTFnName>addLink</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;<A CLASS=APT HREF="../../norsys/netica/Node.html">Node</A></span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentNode</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
            throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Adds a link from <span CLASS="paramNm">parentNode</span> to this node, and returns the index of the added link.
  <p>This index will  be one greater than that of the previously added link, and the existing links will maintain their same indexes.
  <p>If this node, the child node, has a table (CPT or function table), its entries are initially duplicated so its values are the same for each possible state of the new parent.  In other words, they are independent of the new parent, so that the link from parent to child has no effect on probability computations until the table is changed.
  <p><span CLASS="paramNm">parentNode</span> must be in the same net as this node, or an exception will be thrown, and no action taken.
  <p>A warning will be generated (which can be detected by calling <A HREF="../../norsys/netica/NeticaError.html#getWarnings(int, norsys.netica.Environ)">getWarnings</A>) if there is already a link from <span CLASS="paramNm">parentNode</span> to this node, or if the added link creates a cycle, but the link will be successfully added.  If you don't remove one of the offending links, and later try to compile the net or do node absorption, an exception will be thrown.
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm"><a href="Node.html">Node</a></span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentNode</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The node which will now be one of our parents, and we its child.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>AddLink_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#deleteLink(int)">deleteLink</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Removes the link between two nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#switchParent(int, norsys.netica.Node)">switchParent</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Switches parents without changing conditional probabilities</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#copyNodes(norsys.netica.NodeList)">copyNodes</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Also duplicates all the links between them</td></tr></table><br><b>Example:</b>
  <pre CLASS="example"><div CLASS=desc>See <A HREF="../../norsys/netica/NeticaError.html#getWarnings(int, norsys.netica.Environ)">getWarnings</A>.</div></pre></DL>
<HR>

<A NAME="addToNodeset(java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>addToNodeset</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>nodeset</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                  throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Adds this node to the node-set named <span CLASS="paramNm">nodeset</span>.
  <p>Creates a new node-set if <span CLASS="paramNm">nodeset</span> is not yet present in the net containing this node.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">nodeset</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">A nodeset name.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 3.22 and later have this method.<br>In the C Version of the API, this function is named <b>AddNodeToNodeset_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#removeFromNodeset(java.lang.String)">removeFromNodeset</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">(inverse operation)  To remove the nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#isInNodeset(java.lang.String)">isInNodeset</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Determines if a node is in a node-set</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#setNodesetColor(java.lang.String, java.awt.Color)"><CODE>Net.setNodesetColor</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Change the display color for Netica Application</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#reorderNodesets(java.lang.String)"><CODE>Net.reorderNodesets</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To change the priority order of a net's node-sets</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#getAllNodesets(boolean)"><CODE>Net.getAllNodesets</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Returns string listing all node-sets defined</td></tr></table><br></DL>
<HR>

<A NAME="addStates(int, java.lang.String, int, double)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>addStates</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>firstState</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>stateNames</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>numStates</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;double</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>cptFill</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
               throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>
  Adds one or more states to this node, inserting them into the existing states.  The first one added will have index <span CLASS="paramNm">firstState</span>, and <span CLASS="paramNm">numStates</span> is the number of states that will be added.  If <span CLASS="paramNm">state</span> is zero, the states will be added before existing ones, and if it is the same as the number of states of the node ( or -1), they will be added at the end.
  <p>The <span CLASS="paramNm">names</span> parameter can be a comma delimited list of new names for the added states, or it can be <span CLASS="reservedWord">null</span>, in which case the added states will be given default names.  It must be <span CLASS="reservedWord">null</span> if the node's states currently do not have names.
  <p>Pass -1.0 for <span CLASS="paramNm">cptFill</span>.  It is only for future expansion.
  <p>This function is for discrete nodes only.  It is not for continuous
  nodes, even if they have been discretized (use <A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A> instead).
  <p>All relevant parts of this node will be properly modified to reflect the changes, including findings. The state titles and state comments of the added states will be absent.
  <p>The CPTable will be appropriately adjusted.  In it, the probability of the new states will be zero.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">firstState</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The insertion point of the states, that is, the index of the first state inserted.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">names</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An optional, comma-delimited list of names to assign to the states.  If <span CLASS="reservedWord">null</span>, then the states will receive default names.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">numStates</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The number of states to add.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">double</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">cptFill</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">For future expandability.  Pass -1.0 for now.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Since version 3.01<br>In the C Version of the API, this function is named <b>AddNodeStates_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/State.html#delete()"><CODE>State.delete</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Removes a single state</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#reorderStates(int[])">reorderStates</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Assign a new order to the states</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">firstState</span> must be between 0 and this, inclusive</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getIndex(java.lang.String)">getIndex</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieve the new indexes of the states</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/General.html#setName(java.lang.String)"><CODE>State.setName</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets name of one state at a time</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/General.html#setTitle(java.lang.String)"><CODE>State.setTitle</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Doesn't have the restrictions of a name</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/General.html#setComment(java.lang.String)"><CODE>State.setComment</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Assigns arbitrary text documentation to a state</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">For continuous nodes</td></tr></table><br></DL>
<HR>

<A NAME="calcState()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>int</span>&nbsp;<span CLASS=PTFnName>calcState</span>&nbsp;(&nbsp;)
              throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns the discrete finding entered for this node if one has been entered, or the state calculated from its neighbors if that can be done deterministically (e.g., by equation or function table), or else <A HREF="../../norsys/netica/State.html#UNDEF_STATE"> UNDEF_STATE</A>.
  <p>If this node is not a discrete or discretized node, then an exception is thrown (then use <A HREF="../../norsys/netica/Node.html#calcValue()">calcValue</A> instead).
  <br><br><b>Version:</b><br><div CLASS="version">Versions 1.18 and later have this method.<br>In the C Version of the API, this function is named <b>CalcNodeState_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#calcValue()">calcValue</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">For real values (i.e., continuous)</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getFinding()">getFinding</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Doesn't do deterministic propagation</td></tr></table><br></DL>
<HR>

<A NAME="calcValue()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>double</span>&nbsp;<span CLASS=PTFnName>calcValue</span>&nbsp;(&nbsp;)
                 throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns the real-valued finding entered for this node if one has been entered, or the real value calculated from its neighbors if that can be done deterministically (e.g., by equation or function table), or else <A HREF="../../norsys/netica/Environ.html#UNDEF_DBL"> UNDEF_DBL</A>.
  <p>If this node is not a continuous node, and doesn't have a levels list defined (see&nbsp;<A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A>), then an exception is thrown (then use <A HREF="../../norsys/netica/Node.html#calcState()">calcState</A> instead).
  
  <br><br><b>Version:</b><br><div CLASS="version">Versions 1.18 and later have this method.<br>In the C Version of the API, this function is named <b>CalcNodeValue_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#calcState()">calcState</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">For discrete nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#GetNodeValueEntered()">GetNodeValueEntered</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Doesn't do deterministic propagation</td></tr></table><br></DL>
<HR>

<A NAME="delete()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>delete</span>&nbsp;(&nbsp;)
            throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Removes this node from its net, and frees all resources (e.g., memory) it was using.
  <p>If this node has children, they will end up with disconnected links for parents, and the names of these links (if they weren't already named) will become the name of this node.  If this node has parents, then links from them will simply be removed.
  <p>If a complete net is to be disposed of, use <A HREF="../../norsys/netica/Net.html#finalize()"><CODE>Net.finalize</CODE></A> instead, which also deletes all its nodes.
  <br><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>DeleteNode_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#Node(java.lang.String, int, norsys.netica.Net)">Node</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">(Inverse operation)  Creates a new node in a net</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#absorbNodes(norsys.netica.NodeList)">absorbNodes</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Maintains joint distribution while removing</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#finalize()"><CODE>Net.finalize</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Deletes all the nodes of a net</td></tr></table><br><b>Example:</b>
  <pre CLASS="example"><div CLASS=desc>The following method is available in NodeListEx.java:</div>
  /** 
   *  Removes all the nodes in nodeList from their net, and deletes them.
   *  @param nodeList  the nodes to delete
   *<Z>/
  static void deleteNodes (NodeList nodeList) throws NeticaException {
      while (nodeList.size() &gt; 0) {
          Node node = (Node) nodeList.remove (0);
          node.delete();
      }
  }</pre></DL>
<HR>

<A NAME="deleteLink(int)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>deleteLink</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentLinkIndex</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Delete the link entering this node from the given parent node.
  Removes the link going to this child from the <span CLASS="paramNm">parentLinkIndex</span>th parent node of this child.
  <p><span CLASS="paramNm">parentLinkIndex</span> should be 0 for the first parent, and must be less than the number of links entering this child (the parent ordering is given by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A>).
  <p>It is often more useful to be able to delete a link by specifying the 2 nodes it connects.  In order to do this use the method deleteLink defined in the example below.
  <p>If this child has a CPT or function table, it is collapsed as if the removed parent were taking on its first state (state = 0), unless there is a positive finding entered for the parent, in which case it is collapsed with the parent taking on the finding state.
  <p><b>WARNING:</b>  When a link is deleted, keep in mind that the numbering of subsequent links changes.  For example, to delete all the links entering a node, use the method "DeleteLinksEntering" example below, <u>not</u>: &nbsp;&nbsp;<span CLASS="code">for (pn = 0;  pn &lt; numParents;  ++pn)  DeleteLink (<u>pn</u>);</span>
  <p><b>WARNING:</b> Keep in mind that after deleting a link into node child, any list of parent nodes for child that was previously returned by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> is no longer valid.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentLinkIndex</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The index of the parent Node whose link we wish to remove.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>DeleteLink_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Adds a link between two nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#switchParent(int, norsys.netica.Node)">switchParent</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Switches parents without changing conditional probabilities<br>(can be used to disconnect link instead of deleting)</td></tr></table><br><b>Example #1:</b>
  <pre CLASS="example"><div CLASS=desc>The following method is available in NodeEx.java:</div>
  /** 
   *  Removes the single link from node 'parent' to node 'child'.
   *  If there is no link from 'parent' to 'child', or more than one, it generates an error.
   *  @param parent the parent node
   *  @param child  the child node
   *<Z>/
  static void deleteLink (Node parent, Node child) throws NeticaException {
      NodeList parents = child.getParents();
      int index = parents.indexOf (parent);
      child.deleteLink (index);
  }</pre>
  <b>Example #2:</b>
  <pre CLASS="example"><div CLASS=desc>The following method is available in NodeEx.java:</div>
  /** 
   *  Removes all links entering node child
   *  See the <A HREF="../../norsys/netica/Node.html#deleteLink(int)">deleteLink</A> comment for explanation
   *  @param child the child node
   *<Z>/
  static void deleteLinksEntering (Node child) throws NeticaException {
      NodeList parents = child.getParents();
      int numParents = parents.size();
      for (int pn = 0;  pn &lt; numParents;  ++pn)
          child.deleteLink (0);
  }</pre></DL>
<HR>

<A NAME="deleteTables()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>deleteTables</span>&nbsp;(&nbsp;)
                  throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>
  Deletes this node's function table, its CPT table, and its experience table.
  <p>It does not modify this node's equation or its links.
  <p>You don't need to call this function if you are deleting the whole node, since <A HREF="../../norsys/netica/Node.html#delete()"><CODE>Node.delete</CODE></A> and <A HREF="../../norsys/netica/Net.html#finalize()"><CODE>Net.finalize</CODE></A> also delete all of their nodes' tables.
  <br><br><b>Version:</b><br><div CLASS="version">Versions 2.07 and later have this method.<br>In the C Version of the API, this function is named <b>DeleteNodeTables_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#hasTable(boolean[])">hasTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Determine if a node currently has a table</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#deleteLink(int)">deleteLink</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Reduce the number of parents of the node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setStateFuncTable(int[], int)">setStateFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Give a node a function table with its parents</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Give a node a probabilistic table (CPT) with its parents</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#Node(java.lang.String, int, norsys.netica.Net)">Node</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Creates a new node without any tables</td></tr></table><br></DL>
<HR>

<A NAME="equationToTable(int, boolean, boolean)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>equationToTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>numSamples</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;boolean</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>includeSamplingUncertainty</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;boolean</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>addExisting</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                     throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Builds the CPT for this node based on the equation that has been associated with it (see&nbsp;<A HREF="../../norsys/netica/Node.html#setEquation(java.lang.String)">setEquation</A>).
  <p><span CLASS="paramNm">numSamples</span> is the number of samples to make per parent condition.  The higher the number, the more accurate the conversion will be, but the longer it will take.  If this node and its parents are discrete, then it only takes one sample to generate an exact probability, and so in that case this argument is ignored.
  <p><span CLASS="paramNm">includeSamplingUncertainty</span> indicates whether to include in the generated probability table the uncertainty due to the sampling process or not.  If the equations are simple (don't have narrow spikes), and the value passed for <span CLASS="paramNm">numSamples</span> is high enough, it is better to make this argument <span CLASS="reservedWord">false</span>, so that the CPT entries for 'impossible' are zero, rather than close to zero.  Otherwise make it <span CLASS="reservedWord">true</span>.
  <p>Normally you pass <span CLASS="reservedWord">false</span> for <span CLASS="paramNm">addExisting</span>, but you can pass <span CLASS="reservedWord">true</span> if you wish the new sampling to be added to the table which already exists.  If the equation conversion to table is nondeterministic (i.e., requires sampling), then calling this method twice with <span CLASS="paramNm">addExisting</span> = <span CLASS="reservedWord">true</span> is equivalent to calling it once with a value of <span CLASS="paramNm">numSamples</span> twice as large.  So you can increase the accuracy of the conversion in small steps by repeatedly calling with <span CLASS="paramNm">addExisting</span> = <span CLASS="reservedWord">true</span>.  Or if you want to blend equations (say you want to indicate a 30% chance of equation 1 and a 70% chance of equation 2), you can call it twice, first setting equation 1 and using <span CLASS="paramNm">numSamples</span> = 3, then setting equation 2 and using <span CLASS="paramNm">numSamples</span> = 7.  Similarly, you can blend equations with learned probabilities (see&nbsp;<A HREF="../../norsys/netica/Net.html#reviseCPTsByCaseFile(norsys.netica.Streamer, norsys.netica.NodeList, double)">reviseCPTsByCaseFile</A>), and those entered manually with <A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A> and <A HREF="../../norsys/netica/Node.html#setExperTable(int[], double)">setExperTable</A>.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">numSamples</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The number of samples to make per parent condition.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">boolean</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">includeSamplingUncertainty</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Whether to include in the generated probability table the uncertainty due to the sampling process or not</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">boolean</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">addExisting</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Whether you wish the new sampling to be added to the table which already exists. Normally <span CLASS="reservedWord">false</span>.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 1.18 and later have this method.<br>In the C Version of the API, this function is named <b>EquationToTable_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setEquation(java.lang.String)">setEquation</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Specifies the equation to be used</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getEquation()">getEquation</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves an equation, if it exists</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getCPTable(int[], float[])">getCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieve the table, if its probabilistic</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getStateFuncTable(int[], int[])">getStateFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieve the table, if its deterministic discrete</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getRealFuncTable(int[], double[])">getRealFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieve the table, if its deterministic continuous</td></tr></table><br></DL>
<HR>

<A NAME="fadeCPTable(double)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>fadeCPTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;double</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>degree</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                 throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Smoothes the conditional probabilities (CPT) of this node to indicate greater uncertainty, which accounts for the idea that the world may have changed a little since they were last learned.
  <p><span CLASS="paramNm">degree</span> must be between 0 and 1, with 0 having no effect and 1 creating uniform distributions with no experience.  Calling <A HREF="../../norsys/netica/Node.html#fadeCPTable(double)">fadeCPTable</A> once with <span CLASS="paramNm">degree</span> = 1-d, and again with <span CLASS="paramNm">degree</span> = 1-f, is equivalent to a single call with <span CLASS="paramNm">degree</span> = 1-df.
  <p>The global variable <span CLASS="paramNm">BaseExperience</span> is used in the calculation as shown below.  It's value should be the same as it was when the learning from cases was done (if it was).  It must be greater than 0, and the most common value for it is 1 (1/2 is also commonly used).  You will normally set it to one of these choices, depending on your philosophy, and leave it that way permanently.
  <p>Each of the probabilities in the node's conditional probability table is modified as follows (where prob and exper are the old values of probability and experience, and prob' and exper' are the new values):
  <p>&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="code">prob'&nbsp;&nbsp;= normalize (prob * exper - (prob * exper - <span CLASS="paramNm">BaseExperience</span>) * <span CLASS="paramNm">degree</span>)</span>
  <br>&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="code">prob'&nbsp;&nbsp;= normalize (prob * exper * (1 - <span CLASS="paramNm">degree</span>) + <span CLASS="paramNm">degree</span>  * <span CLASS="paramNm">BaseExperience</span>)</span>
  <br>&nbsp;&nbsp;exper' is obtained as the normalization factor from above.  So:
  <br>&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="code">prob' * exper' = prob * exper * (1 - <span CLASS="paramNm">degree</span>) + <span CLASS="paramNm">degree</span> * <span CLASS="paramNm">BaseExperience</span></span>
  <p>When learning in a changing environment, you would normally call fadeCPTable every once in a while, so that what has been recently learned is more strongly weighted than what was learned long ago.  If an occurrence time for each case is known, and the cases are learned sequentially through time, then the amount of fading to be done is:<br><span CLASS="paramNm">degree</span> = 1 - r<sup><FONT face="Symbol">D</FONT>t</sup>  where <FONT face="Symbol">D</FONT>t is the amount of time since the last fading was done, and r is a number less than, but close to, 1 and depends on the units of time and how quickly the environment is changing.  See the example below.
  
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">double</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">degree</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The amount by which to fade the probability tables; 0.0 &lt;= degree &lt;= 1.0</td></tr></table><br><b>Version:</b><br><div CLASS="version">In the C Version of the API, this function is named <b>FadeCPTable_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#reviseCPTsByFindings(norsys.netica.NodeList, double)">reviseCPTsByFindings</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Is passed a 'degree', which also can be used to weight the impact of learning a case</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getCPTable(int[], float[])">getCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Read out the faded probabilities table</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getExperTable(int[], double[])">getExperTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Read out the faded experience table</td></tr></table><br><b>Example #1:</b>
  <pre CLASS="example">
  // The following does the same fading for a list of nodes:
  //
  static void fadeCPTsForNodes (NodeList nodes, double degree) throws NeticaException {
      for (int n = 0;  n &lt; nodes.size();  ++n){
          Node node = (Node) nodes.get(n);
          node.fadeCPTable (degree);
      }
  }</pre>
  <b>Example #2:</b>
  <pre CLASS="example">
  // The following bit of code may be executed in a loop which is
  //   traversed as the cases are learned, in order to do the
  //   required fading:
  //     time - the occurrence time of the last case learned
  //     lastTime - a number initialized to the time of the 1st case
  //     minDelay - a number controlling how often fading is done
  //     rate - a number determining how much fading is done
  //     net - the net being learned
  if ((time - lasttime) &gt;= minDelay){
      double degree = 1.0 - Math.pow (rate, (double) (time - lasttime));
      fadeCPTsForNodes (net.getNodes(), degree);
      lasttime = time;
  }
  </pre></DL>
<HR>

<A NAME="finalize()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>finalize</span>&nbsp;(&nbsp;)
              throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Called by the garbage collector, when this node can no longer be referenced.
  <p>If in your application the native node associated with this node will no longer needed when this node is to be garbage collected, then you may wish to override this method and call <A HREF="../../norsys/netica/Node.html#delete()">delete</A> in your finalize() method.
  <p>You may, however, wish to call it directly to ensure or hasten the freeing of native resources.
  <p><b>If you do override this method, be sure to call the base class method (super.finalize();).</b>
  <br><br><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#delete()">delete</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Frees the native resources used by this node</td></tr></table><br><DD><DL>
<DT><B>Overrides:</B><DD><CODE>finalize</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="finding()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype><A CLASS=APT HREF="../../norsys/netica/Value.html">Value</A></span>&nbsp;<span CLASS=PTFnName>finding</span>&nbsp;(&nbsp;)</td></tr></table></div>
<DL>
<DD>Returns the Value object holding this node's finding (aka, "evidence") information.
  <p>Call that object's methods to manage the findings information for this node.
  <br><br><b>Version:</b><br><div CLASS="version">In version 2.26 and later.
  </div><b>Example:</b>
  <pre CLASS="example">
  node.finding().setState (0);  // claim finding that node is in state 0</pre></DL>
<HR>

<A NAME="getBelief(java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>float</span>&nbsp;<span CLASS=PTFnName>getBelief</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>stateName</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Gets the belief that this node is in the given named state.  A convenience method based on <A HREF="../../norsys/netica/Node.html#getBeliefs()">getBeliefs</A>.    See that method for more detailed documentation.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">stateName</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The name of the state whose belief value we seek.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getBeliefs()">getBeliefs</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves beliefs for all states</td></tr></table><br></DL>
<HR>

<A NAME="getBeliefs()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>float[]</span>&nbsp;<span CLASS=PTFnName>getBeliefs</span>&nbsp;(&nbsp;)
                   throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>
  Returns a belief vector indicating the current probability for each state of this node. 
  <p>The vector will be indexed by states, with one probability for each state (if required, the state indexes can be found from their names using <A HREF="../../norsys/netica/General.html#getIndex()">state("stateName").getIndex()</A>).  It will be normalized, so that the sum of its entries is 1.
  <p>This provides the current beliefs (i.e., posterior probabilities) that the variable represented by this node is in each of its states, given the net model and all findings entered into all nodes of the net (positive findings, negative findings and likelihood findings).
  <p>The net containing this node must have been compiled before calling this (with <A HREF="../../norsys/netica/Net.html#compile()">compile</A>), or an exception will be thrown.  If the net has been modified it must be recompiled, but just entering findings does not require a recompile.
  <p>this node should be a discrete or discretized nature node.
  <p>If belief updating hasn't been done since the last findings were entered, it will be done before this method returns, which can be time consuming (you can call <A HREF="../../norsys/netica/Node.html#isBeliefUpdated()">isBeliefUpdated</A> before calling this to find out if belief updating will be done).
  <p>If you need the beliefs to persist, make a copy of the vector returned, since its contents may become invalid after further calls to Netica API.  Do not try to directly modify or free the vector returned.
  <br><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>GetNodeBeliefs_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#isBeliefUpdated()">isBeliefUpdated</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Tells whether getBeliefs will trigger belief updating</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Determine length of vector returned</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#getJointProbability(norsys.netica.NodeList, int[])">getJointProbability</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">More than one node at a time</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#compile()">compile</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To do the initial compiling before entering findings</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getExpectedUtils()">getExpectedUtils</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Get the resulting expected utility of a decision node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getExpectedValue(double[])">getExpectedValue</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">For numeric nodes, get expected value and standard deviation</td></tr></table><br><b>Example:</b>
  <pre CLASS="example">
  // This method is useful to get the belief that a certain node is in
  // a certain state, based on the names of the node and state.
  //
  static float getBelief (String nodeName, String stateName, Net net) throws NeticaException {
      Node node = net.getNode (nodeName);
      int stateIndex = node.state(stateName).getIndex();
      return node.getBeliefs()[stateIndex];
  }</pre></DL>
<HR>

<A NAME="getChildren()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype><A CLASS=APT HREF="../../norsys/netica/NodeList.html">NodeList</A></span>&nbsp;<span CLASS=PTFnName>getChildren</span>&nbsp;(&nbsp;)
                     throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns a list of the children of this node.  Those are the nodes that have a link going to them from this node.  If it has no children then the empty list (rather than <span CLASS="reservedWord">null</span>) will be returned.
  <p>If there are several links from this node to the same child, then that child will appear only once in the list returned, so the length of the returned list may be used to provide the number of unique children of this node.
  
  <p>Consecutive calls to this method may yield lists in different orders.
  <br><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>GetNodeChildren_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getParents()">getParents</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Get a list of the parents</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Create a new child</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#deleteLink(int)">deleteLink</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Remove a child</td></tr></table><br></DL>
<HR>

<A NAME="getConstructorClass()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;<span CLASS=PTFntype>String</span>&nbsp;<span CLASS=PTFnName>getConstructorClass</span>&nbsp;(&nbsp;)</td></tr></table></div>
<DL>
<DD>Retrieves the classname of the class that Netica-J uses when constructing a Node. This is the class Netica-J uses, for example, during the process of retrieving the nodes from a net that was read from file.
 <br><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.
 </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setConstructorClass(java.lang.String)">setConstructorClass</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Set the className to be used for this purpose</td></tr></table><br></DL>
<HR>

<A NAME="getCPTable(int[], float[])"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>float[&nbsp;]</span>&nbsp;<span CLASS=PTFnName>getCPTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentStates</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;float[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>cpTable</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                   throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns the conditional probabilities of this node, given that its parents are in the states indicated by the <span CLASS="paramNm">parentStates</span> vector, by looking them up in the node's CPT table.  The length of <span CLASS="paramNm">parentStates</span> must be the number of parents of this node, and each of its entries provides a state for the corresponding parent.  The length of the array returned is the number of states of this node, and consists the conditional probabilities:
  <p>&nbsp;&nbsp;P (this node = state0  | parents take on <span CLASS="paramNm">parentStates</span>)
  <p>&nbsp;&nbsp;P (this node = state1  | parents take on <span CLASS="paramNm">parentStates</span>)
  <p>&nbsp;&nbsp;      <b>...</b>
  <p>&nbsp;&nbsp;P (this node = stateN  | parents take on <span CLASS="paramNm">parentStates</span>)
  <p>Notice that it is not conditioned on any findings (evidence) entered into the net, so its value will not change as findings are added or belief updating is done.
  <p><span CLASS="reservedWord">null</span> will be returned if no CPT table has been associated with this node (for example by <A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A>, <A HREF="../../norsys/netica/Node.html#setStateFuncTable(int[], int)">setStateFuncTable</A>, <A HREF="../../norsys/netica/Node.html#equationToTable(int, boolean, boolean)">equationToTable</A>, <A HREF="../../norsys/netica/Net.html#reviseCPTsByCaseFile(norsys.netica.Streamer, norsys.netica.NodeList, double)">reviseCPTsByCaseFile</A> or <A HREF="../../norsys/netica/Net.html#reviseCPTsByFindings(norsys.netica.NodeList, double)">reviseCPTsByFindings</A>), or if the table has been removed (for example by <A HREF="../../norsys/netica/Node.html#deleteTables()">deleteTables</A>), but no exception will be thrown.  If you use only <A HREF="../../norsys/netica/Node.html#setEquation(java.lang.String)">setEquation</A> to indicate a node's relation with its parents, you must also call <A HREF="../../norsys/netica/Node.html#equationToTable(int, boolean, boolean)">equationToTable</A> before this will return non-<span CLASS="reservedWord">null</span>.
  <p>The order of the states in <span CLASS="paramNm">parentStates</span> should match the order of the nodes in the list returned by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> (this will be the same order that parents were added using <A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A>).  <A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A> may be useful for that.  <span CLASS="paramNm">parentStates</span> can be <span CLASS="reservedWord">null</span> if this node has no parents.
  <p><span CLASS="paramNm">parentStates</span> should not include <A HREF="../../norsys/netica/State.html#EVERY_STATE"> EVERY_STATE</A> or <A HREF="../../norsys/netica/State.html#UNDEF_STATE"> UNDEF_STATE</A>.
  <p>If <A HREF="../../norsys/netica/Node.html#setStateFuncTable(int[], int)">setStateFuncTable</A> was used to provide this node with a function table, then getCPTable can be used to retrieve that table in the form of conditional probabilities, which will all be 0 or 1.
  
  <p>To get all the conditional probabilities of this node at once, see the GetNodeAllProbs example below.
  
  <p>If you will be regularly calling this method on this node, then you may wish to re-use the array to be filledbt supplying it as parameter <span CLASS="paramNm">cpTable</span>, in order to avoid the continuous allocation of new memory.  If <span CLASS="paramNm">cpTable</span> is <span CLASS="reservedWord">null</span> or too small, then a new array will be allocated and returned.
  <p>If <span CLASS="paramNm">parentStates</span> is <span CLASS="reservedWord">null</span> then the entire table is returned.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentStates</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array of state indexes (one per parent) for which the Conditional Probabilities are desired.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">float[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">cpTable</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array to be reused and filled with the probabilities.  May be  <span CLASS="reservedWord">null</span>, in which case a new array will be allocated and returned.  Otherwise, it should have at least as many elements as the number of states of this node.  If it does not, then a new array will be allocated and returned.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>GetNodeProbs_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets them</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#hasTable(boolean[])">hasTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Determine if <A HREF="../../norsys/netica/Node.html#getCPTable(int[], float[])">getCPTable</A> is going to return <span CLASS="reservedWord">null</span></td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getBeliefs()">getBeliefs</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Conditioned on findings, but not parents</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#absorbNodes(norsys.netica.NodeList)">absorbNodes</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Can be used to find probabilities conditioned on parents and findings</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getStateFuncTable(int[], int[])">getStateFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">For deterministic nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getExperTable(int[], double[])">getExperTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The confidence of the probabilities obtained</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getParents()">getParents</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Indicates the order of entries in parent_states</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Length of the array returned (plus one if node continuous)</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To create the state list passed in</td></tr></table><br><b>Example #1:</b>
  <pre CLASS="example">
  // To just get the probability that node is in <span CLASS="paramNm">state</span>, given <span CLASS="paramNm">parentStates</span>
  //
  double prob = node.getCPTable(parentStates) [state];</pre>
  <b>Example #2:</b>
  <pre CLASS="example">
  // Puts all the conditional probabilities of <span CLASS="paramNm">node</span> into the array <span CLASS="paramNm">probs</span>.
  // You could allocate <span CLASS="paramNm">probs</span> as follows<div CLASS=desc>The following method is available in NodeEx.java:</div>
  /** 
   *  Returns all the conditional probabilities of a given node as a 2-D array.
   *  You may supply an array to re-use.  If it is null, however, then one will be supplied.
   *  @param node  is the node whose CPT we are retrieving
   *  @param probs is an array of probabilities, the first dimension being of size equal to 
   *	           the size of cartesian product of the states of each parent of node. 
   *               The second dimension is the number of states of node.
   *               i.e., float[][] probs = new float[(int) NodeListEx.sizeCartesianProduct (node.getParents())]
   *                                                [node.getNumberStates()];
   *               It may be null, in which case an array will be allocated for you.
   *<Z>/
  static void getNodeAllProbs (Node node, float[][] probs) throws NeticaException {
      NodeList parents = node.getParents();
      int numStates  = node.getNumStates();
      int[] parentStates = new int[parents.size()];  //initially all zero
      int probSet = 0;
      while (true){
          float[] vecp = node.getCPTable (parentStates, null);
          if (vecp == null)  break;
          for (int st = 0;  st &lt; numStates;  ++st)  probs[probSet][st] = vecp[st];
          if (NodeListEx.nextStates (parentStates, parents)) 
              break;
          ++probSet;
      }
  }</pre></DL>
<HR>

<A NAME="getCPTable(java.lang.String, float[])"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>float[&nbsp;]</span>&nbsp;<span CLASS=PTFnName>getCPTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentStatesStr</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;float[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>cpTable</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                   throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>This does the same as <A HREF="../../norsys/netica/Node.html#getCPTable(int[], float[])">getCPTable(int[], float[])</A> except that it takes the parent states as a string rather than as an integer array.  For additional documentation, see <A HREF="../../norsys/netica/Node.html#getCPTable(int[], float[])">getCPTable(int[], float[])</A>.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentStates</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array of state indexes (one per parent) for which the Conditional Probabilities are desired.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">float[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">cpTable</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array to be reused and filled with the probabilities.  May be  <span CLASS="reservedWord">null</span>, in which case a new array will be allocated and returned.  Otherwise, it should have at least as many elements as the number of states of this node.  If it does not, then a new array will be allocated and returned.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setCPTable(java.lang.String, float[])">setCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets them</td></tr></table><br></DL>
<HR>

<A NAME="getCPTable(float[])"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>float[&nbsp;]</span>&nbsp;<span CLASS=PTFnName>getCPTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;float[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>cpTable</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                   throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Retrieves the entire CPTable of this node as a 1-D array.
  <p>See the example below for how the retrieved probabilities will be arranged.  Basically, the rule is that the largest indexed parent's states will vary most rapidly, then the second largest indexed parent's states, and so on.
  <p>The 1-D array may be given to the inverse method <A HREF="../../norsys/netica/Node.html#setCPTable(float[])">setCPTable</A>.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">float[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">cpTable</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array to be reused and filled with the probabilities from the entire CPTable.  May be  <span CLASS="reservedWord">null</span>, in which case a new array will be allocated and returned.  Otherwise, it should have sufficient space for the entire CPTable.  If it does not, then a new array will be allocated and returned.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setCPTable(float[])">setCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets it</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getCPTable(int[], float[])">getCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieve part of the table instead</td></tr></table><br><b>Example #1:</b>
  <pre CLASS="example">
  Suppose you have a node with 4 states and it has two parents.  
  Parent1 has 2 states (say 'true' and 'false').
  Parent2 has 3 states (say 'red', 'green', and 'blue'). 
  The CPT for the node is initially as follows:
   
                        |  Probabilities that node is in 
      parent1  parent2  |  state1  state2  state3  state4  
      -------  ------   |  ------  ------  ------  ------
      true     red      |  0.0     0.8     0.2     0.0
      true     green    |  0.1     0.7     0.2     0.0
      true     blue     |  0.1     0.1     0.1     0.7
      false    red      |  0.0     0.0     0.0     1.0
      false    green    |  0.0     0.0     0.2     0.8
      false    blue     |  1.0     0.0     0.0     0.0
  
  You want to retrieve the above table.
    You can do this easily by calling:
  float[] probs = node.getCPTable (null); //sets probs to an array of length 24
    
  float[] probs2 = {0.0F, 0.8F, 0.2F, 0.0F,
                    0.1F, 0.7F, 0.2F, 0.0F,
                    0.1F, 0.1F, 0.1F, 0.7F,
                    0.0F, 0.0F, 0.0F, 1.0F,
                    0.0F, 0.0F, 0.2F, 0.8F,
                    1.0F, 0.0F, 0.0F, 0.0F};
  Arrays.equals (probs, probs2); //evaluates to true.</pre>
  <b>Example #2:</b>
  <pre CLASS="example">
  If you want to do fetch the above node's CPT repeatedly, you can save on
  the heap allocation of a new array each time as follows:
    
  float[] probs = node.getCPTable (null);
  while(...){
    ...
    node.getCPTable (probs); //reuses probs, filling it with node's CPT values
    ...
  }</pre></DL>
<HR>

<A NAME="getEquation()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>String</span>&nbsp;<span CLASS=PTFnName>getEquation</span>&nbsp;(&nbsp;)
                             throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns the equation associated with this node, or the empty string (rather than <span CLASS="reservedWord">null</span>), if this node does not have an equation.
  <p>For information on Netica equations, see the "Equation" chapter of Netica Application's onscreen help.
  
  <br><br><b>Version:</b><br><div CLASS="version">Versions 1.30 and later have this method.<br>In the C Version of the API, this function is named <b>GetNodeEquation_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setEquation(java.lang.String)">setEquation</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets it</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#equationToTable(int, boolean, boolean)">equationToTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">If this hasn't been done, equation may not match CPT table</td></tr></table><br></DL>
<HR>

<A NAME="getExpectedUtils()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>float[]</span>&nbsp;<span CLASS=PTFnName>getExpectedUtils</span>&nbsp;(&nbsp;)
                         throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns a vector providing the expected utility of each choice in a decision node, considering findings currently entered.
  <p>The vector will be indexed by states, with one utility for each state (i.e., choice).
  <p>The net containing this node must be a decision net (i.e., have decision and utility nodes), which has been compiled before calling this (with <A HREF="../../norsys/netica/Net.html#compile()">compile</A>), or an exception will be thrown.  If the net has been modified it must be recompiled, but just entering findings does not require a recompile.
  <p>Before calling this all preceding decision nodes must have positive findings entered.
  <p>this node must be a decision node.
  <p>If belief updating hasn't been done since the last findings were entered, it will be done before this method returns, which can be time consuming (you can call <A HREF="../../norsys/netica/Node.html#isBeliefUpdated()">isBeliefUpdated</A> before calling this to find out if belief updating will be done).
  
  <p>If you wish to retrieve a whole table of values, providing the optimal state to choose given the parent states, use <A HREF="../../norsys/netica/Node.html#getStateFuncTable(int[], int[])">getStateFuncTable</A>.
  <br><br><b>Version:</b><br><div CLASS="version">Versions 1.07 and later have this method.<br>In the C Version of the API, this function is named <b>GetNodeExpectedUtils_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getStateFuncTable(int[], int[])">getStateFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieve table of optimal choices as a function of parent values</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Determine the length of the vector returned</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getBeliefs()">getBeliefs</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">For the beliefs of a nature node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getExpectedValue(double[])">getExpectedValue</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Don't confuse it with this method, which gets the expected real value of a nature node</td></tr></table><br></DL>
<HR>

<A NAME="getExpectedValue(double[])"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>double</span>&nbsp;<span CLASS=PTFnName>getExpectedValue</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;double[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>moments</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                        throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns the expected real value of this node, based on the current beliefs for this node, and if <span CLASS="paramNm">moments</span> is non-<span CLASS="reservedWord">null</span>, <span CLASS="paramNm">moments</span> will be filled with the moments as well. <span CLASS="paramNm">moments</span>[0] will be assigned the 1st moment ( the expected value, the same value that is returned by this method) and <span CLASS="paramNm">moments</span>[1] will be assigned the 2nd moment (the standard deviation).  Currently, only the first two moments are available, so if <span CLASS="paramNm">moments</span> has more than two elements, the third onward are not set.<p>Returns <A HREF="../../norsys/netica/Environ.html#UNDEF_DBL"> UNDEF_DBL</A> if the expected value couldn't be calculated.
  
  <p>This node must be continuous discretized, or must be discrete with a levels list defined to supply real values.
  <p>For continuous discretized nodes it assumes the belief for each state is distributed evenly over each discretized interval.  Because of that, it can't handle infinite tails (returns <A HREF="../../norsys/netica/Environ.html#UNDEF_DBL"> UNDEF_DBL</A>).
  <p>This method is not for expected utility; for that see <A HREF="../../norsys/netica/Node.html#getExpectedUtils()">getExpectedUtils</A>.
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">double[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">moments</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">an array, which if non-<span CLASS="reservedWord">null</span>, will have up to its 0th and 1st elements set to the 1st and 2nd moments, respectively.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 2.09 and later have this method.<br>In the C Version of the API, this function is named <b>GetNodeExpectedValue_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getBeliefs()">getBeliefs</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Returns beliefs for each state individually</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getExpectedUtils()">getExpectedUtils</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">For expected utility, rather than expected real value</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Value.html#getReal()">finding().getReal()</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves a specific real-valued finding instead</td></tr></table><br></DL>
<HR>

<A NAME="getExperTable(int[], double[])"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>double[&nbsp;]</span>&nbsp;<span CLASS=PTFnName>getExperTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentStates</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;double[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>experTable</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                       throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Given <span CLASS="paramNm">parentStates</span>, a vector of states for the parents of this node, this returns the "experience" of the node for the situation described by the parent states.
  <p>If <span CLASS="paramNm">experTable</span> is not <span CLASS="reservedWord">null</span> it will be used to hold the returned value, rather than allocate a new array, and it will be the array reference returned.
  <p>The experience is also known as the "number of cases", ess, or estimated sample size.
  <p>If no experience value has been assigned to this parent configuration (either by learning or <A HREF="../../norsys/netica/Node.html#setExperTable(int[], double)">setExperTable</A>), then <A HREF="../../norsys/netica/Environ.html#UNDEF_DBL"> UNDEF_DBL</A> is returned, without generating an error.
  <p>The order of the states in <span CLASS="paramNm">parentStates</span> should match the order of the nodes in the list returned by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> (this will be the same order that parents were added using <A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A>).  <A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A> may be useful for that.  <span CLASS="paramNm">parentStates</span> can be <span CLASS="reservedWord">null</span> if this node has no parents.
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentStates</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array of state indexes (one per parent) with which to compute and return our experience value.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">double[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">experTable</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array to be reused and filled with the experience values.  May be <span CLASS="reservedWord">null</span>, in which case a new array will be allocated and returned.  Otherwise, it should have at least one element.  If it does not, then a new array will be allocated and returned.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>GetNodeExperience_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setExperTable(int[], double)">setExperTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets them</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getCPTable(int[], float[])">getCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Get the corresponding probability vector</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#reviseCPTsByFindings(norsys.netica.NodeList, double)">reviseCPTsByFindings</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Increments experience</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#reviseCPTsByCaseFile(norsys.netica.Streamer, norsys.netica.NodeList, double)">reviseCPTsByCaseFile</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Experience will measure the number of cases with each parent configuration</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To create the state list passed in</td></tr></table><br><b>Example:</b>
  <pre CLASS="example">
  //Here is a convenience method taking parentStates as a comma and/or space delimited string.
  public int[] getExperTable (String parentStatesStr) throws NeticaException {
      return getExperTable (parentStatesToIndexes (parentStatesStr), null);
  }</pre></DL>
<HR>

<A NAME="getInputIndex(java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>int</span>&nbsp;<span CLASS=PTFnName>getInputIndex</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>linkName</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                  throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns the link index number of the link whose name is <span CLASS="paramNm">linkName</span>, or -1 if there isn't one with that name (case sensitive comparison).  This is the same index as would be used to find the parent of the link in the node list returned by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A>.
  <p>The value returned is particular to the node passed; another node may have a link with the same name, but a different link index.
  
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">linkName</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The name of a parent node.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 2.07 and later have this method.<br>In the C Version of the API, this function is named <b>GetInputNamed_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getInputName(int)">getInputName</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">(inverse method)  Returns the name of a link given its index</td></tr></table><br></DL>
<HR>

<A NAME="getInputName(int)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>String</span>&nbsp;<span CLASS=PTFnName>getInputName</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>inputIndex</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                              throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Gets the name of this node's input (i.e., link) identified by the given index. <p>Returns a string which is the name for input number <span CLASS="paramNm">inputIndex</span> of this node, or the empty string (rather than <span CLASS="reservedWord">null</span>) if the link does not have a name.  Numbering for <span CLASS="paramNm">inputIndex</span> starts at 0 and proceeds in the same order as parents returned by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A>.
  <p>If the name is present, you can count on it to be a legal IDname, which means that it is <A HREF="../../norsys/netica/General.html#NAME_MAX"> NAME_MAX</A> (30) or fewer characters (not including terminating 0).
  <p>Input names are used to document what each link means, local to the node, which is especially important if the link is disconnected, or if its parents are continuously being switched.  They are also useful as local parameters in equations, instead of using the names of parents' nodes, so the equation stays valid even if the parents change.
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">inputIndex</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The index of the input Node whose link name we seek.</td></tr></table><br><b>Version:</b><br><div CLASS="version">In the C Version of the API, this function is named <b>GetNodeInputName_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setInputName(int, java.lang.String)">setInputName</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets it</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getParents()">getParents</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Gets the actual parents of the links</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getInputIndex(java.lang.String)">getInputIndex</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">(inverse method)  Returns input index given the name</td></tr></table><br></DL>
<HR>

<A NAME="getKind()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>int</span>&nbsp;<span CLASS=PTFnName>getKind</span>&nbsp;(&nbsp;)
            throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns whether this node is a nature, decision, utility or constant node.
  <p>The value returned will be one of:
  <table CLASS="body">
  <tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#NATURE_NODE"> NATURE_NODE</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Bayes nets are composed only of this type (and constant nodes). <br>This is a "chance" or "deterministic" node of an influence diagram.</td></tr>
  <tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#DECISION_NODE"> DECISION_NODE</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Indicates a variable that can be controlled.<br>This is a "decision" node of an influence diagram.</td></tr>
  <tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#UTILITY_NODE"> UTILITY_NODE</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">A variable to maximize the expected value of.<br>This is a "value" node of an influence diagram.</td></tr>
  
  <tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#CONSTANT_NODE"> CONSTANT_NODE</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">A fixed parameter, useful as an equation constant.<br>When its value changes, equations should be reconverted to CPT tables, and maybe the net recompiled.</td></tr>
  <tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#DISCONNECTED_NODE"> DISCONNECTED_NODE</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The (virtual) parent node of a link which has been disconnected.  See example code below.</td></tr>
  </table>
  <br><br><b>Version:</b><br><div CLASS="version">In the C Version of the API, this function is named <b>GetNodeKind_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setKind(int)">setKind</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets it</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#isDeterministic()">isDeterministic</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To distinguish between "chance" and "deterministic" nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getType()">getType</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Indicates whether the node is for a discrete or continuous variable</td></tr></table><br><b>Example:</b>
  <pre CLASS="example"><div CLASS=desc>The following method is available in NodeEx.java:</div>
  /** 
   *  Determines whether a link entering a node is disconnected.
   *  @param linkIndex the index number of the link in question
   *  @param node      the node of interest
   *  @returns true, iff the link is disconnected.
   *<Z>/
  static boolean isLinkDisconnected (int linkIndex, Node node) throws NeticaException {
      NodeList parents = node.getParents();
      Node parent = (Node) parents.get (linkIndex);
      return (parent.getKind() == Node.DISCONNECTED_NODE);
  }</pre></DL>
<HR>

<A NAME="getLevels()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>double[]</span>&nbsp;<span CLASS=PTFnName>getLevels</span>&nbsp;(&nbsp;)
                   throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns the list of numbers used to enable a continuous node to act discrete, or enables a discrete node to provide real-valued numbers.  Levels are used to discretize continuous nodes, or to map from discrete nodes to real numbers.  See <A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A> for a full description of the level numbers.
  <p>Returns <span CLASS="reservedWord">null</span> if this node does not have a levels list.
  
  <p>Since the usage of levels is a little different for each type of node, each is discussed separately:
  <p><b><!-- 22 -->this node is continuous:</b>  (<A HREF="../../norsys/netica/Node.html#getType()">getType</A> would return <A HREF="../../norsys/netica/Node.html#DISCRETE_TYPE"> DISCRETE_TYPE</A>)
  <p>The length of the list returned is one more than the number of states of this node.  The node is discretized into states, and the list returned has the thresholds (monotonically increasing or decreasing).  Each range is from <span CLASS="paramNm">levels</span>[state] to <span CLASS="paramNm">levels</span>[state+1]., where <span CLASS="paramNm">levels</span> is the list returned.  Normally each interval includes its lower endpoint, but not its upper.
  <p><b><!-- 22 -->this node is discrete:</b>  (<A HREF="../../norsys/netica/Node.html#getType()">getType</A> would return <A HREF="../../norsys/netica/Node.html#CONTINUOUS_TYPE"> CONTINUOUS_TYPE</A>)
  <p>The length of the list returned is the number of states of this node, with each element being the real number associated with the corresponding state.
  <br><br><b>Version:</b><br><div CLASS="version">In version 2.07 and later.<br>In the C Version of the API, this function is named <b>GetNodeLevels_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets them</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Length of the vector returned (plus one if this node continuous)</td></tr></table><br></DL>
<HR>

<A NAME="getNet()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype><A CLASS=APT HREF="../../norsys/netica/Net.html">Net</A></span>&nbsp;<span CLASS=PTFnName>getNet</span>&nbsp;(&nbsp;)</td></tr></table></div>
<DL>
<DD>Returns the net that this node is part of.  Every node is part of some net.
  <br><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>GetNodeNet_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#getNodes()">getNodes</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">(inverse method)  Get the list of nodes comprising a net</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#copyNodes(norsys.netica.NodeList)">copyNodes</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Copy nodes from one net to another</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#Net(norsys.netica.Environ)">Net</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Originally created the net</td></tr></table><br></DL>
<HR>

<A NAME="getNumStates()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>int</span>&nbsp;<span CLASS=PTFnName>getNumStates</span>&nbsp;(&nbsp;)
                 throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns the number of states that this node can take on, or zero if this node is a continuous node that hasn't been discretized.
  <br><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>GetNodeNumberStates_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#Node(java.lang.String, int, norsys.netica.Net)">Node</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets the number of states for a discrete node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets the number and boundaries of discretization for a continuous node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/General.html#getName()"><CODE>State.getName</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"></td></tr></table><br><b>Example:</b>
  <pre CLASS="example"><div CLASS=desc>See the examples for <A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A>.</div></pre></DL>
<HR>

<A NAME="getParents()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype><A CLASS=APT HREF="../../norsys/netica/NodeList.html">NodeList</A></span>&nbsp;<span CLASS=PTFnName>getParents</span>&nbsp;(&nbsp;)
                    throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns a list of the parents of this node.  Those are the nodes with a link going to this node.  If it has no parents then an empty list (rather than <span CLASS="reservedWord">null</span>) will be returned.
  <p>The order of the list is significant.  Numbering each node in the list (starting from 0) provides a numbering for the links entering this node, which is used by some other methods.
  <p>If there are several links from the same parent to this node, then in the list returned that parent will be repeated once for each link.
  <p>To obtain the number of links entering this node, use the length of the returned list.
  
  <br><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>GetNodeParents_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getChildren()">getChildren</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Gets a list of the children</td></tr><tr><td VALIGN="top">java.util.Vector.length()</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Use on returned list to find the number of parents</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getInputName(int)">getInputName</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"></td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Add a parent</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#deleteLink(int)">deleteLink</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Remove a parent</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#switchParent(int, norsys.netica.Node)">switchParent</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Switch one of the parents for a different one</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getKind()">getKind</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To determine if a link is disconnected (returns <A HREF="../../norsys/netica/Node.html#DISCONNECTED_NODE"> DISCONNECTED_NODE</A>)</td></tr><tr><td VALIGN="top"></td></tr></table><br></DL>
<HR>

<A NAME="getRealFuncTable(int[], double[])"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>double[&nbsp;]</span>&nbsp;<span CLASS=PTFnName>getRealFuncTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentStates</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;double[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>realTable</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                          throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Gets the real value of this node as a function of its parent nodes. The value returned is in an array which currently has only one element.
  <p>If <span CLASS="paramNm">realTable</span> is not <span CLASS="reservedWord">null</span> it will be used to hold the returned value, rather than allocate a new array, and it will be the array reference returned. <p>This is for deterministic nodes that are continuous or have been given real levels (e.g., by <A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A>).  Given a vector of states for the parents of this node, this returns the real value of this node (which is functionally determined by the parent values) by looking it up in the nodes function table. If the function table between this node and its parents has not yet been created, or if it is probabilistic (i.e., a CPT) rather than deterministic, this returns <A HREF="../../norsys/netica/Environ.html#UNDEF_DBL"> UNDEF_DBL</A>, without generating an error.
  <p>If this node is discrete, with no real levels defined, an exception will be thrown (use <A HREF="../../norsys/netica/Node.html#getStateFuncTable(int[], int[])">getStateFuncTable</A> instead).
  <p>The order of the states in <span CLASS="paramNm">parentStates</span> should match the order of the nodes in the list returned by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> (this will be the same order that parents were added using <A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A>).  <A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A> may be useful for that.  <span CLASS="paramNm">parentStates</span> can be <span CLASS="reservedWord">null</span> if this node has no parents.
  <p>If the node has been given a deterministic equation with <A HREF="../../norsys/netica/Node.html#setEquation(java.lang.String)">setEquation</A>, you must call <A HREF="../../norsys/netica/Node.html#equationToTable(int, boolean, boolean)">equationToTable</A> before this can be used to retrieve values (if you needed to find values without generating the whole table you would enter findings for the parents, and use <A HREF="../../norsys/netica/Node.html#calcValue()">calcValue</A>).
  <p>This method ignores any findings entered in the net.
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentStates</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array of state indexes (one per parent) with which to compute and return our real function value.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">double[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">realTable</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array to be reused and filled with the real values.  May be <span CLASS="reservedWord">null</span>, in which case a new array will be allocated and returned.  Otherwise, it should have at least one element.  If it does not, then a new array will be allocated and returned.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 2.07 and later have this method.<br>In the C Version of the API, this function is named <b>GetNodeFuncReal_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setRealFuncTable(int[], double)">setRealFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets them</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getStateFuncTable(int[], int[])">getStateFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Same, but returns state integer instead of real value</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#isDeterministic()">isDeterministic</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To check if this method is applicable</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To create the state list passed in</td></tr></table><br><b>Example:</b>
  <pre CLASS="example">
  //Here is a convenience method taking parentStates as a comma and/or space delimited string.
  //It is from the class NodeEx which extends Node.
  public int[] getRealFuncTable (String parentStatesStr) throws NeticaException {
      return getRealFuncTable (parentStatesToIndexes (parentStatesStr), null);
  }</pre></DL>
<HR>

<A NAME="getRelatedNodes(norsys.netica.NodeList, java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>getRelatedNodes</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;<A CLASS=APT HREF="../../norsys/netica/NodeList.html">NodeList</A></span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>relatedNodes</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>relation</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                     throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Finds all the Nodes that bear the relationship <span CLASS="paramNm">relation</span> with this node and puts them in <span CLASS="paramNm">relatedNodes</span>.
  <p><span CLASS="paramNm">relation</span> should be one of "parents", "children", "ancestors", "descendents", "connected", "markov_blanket", "d_connected", or the singular version of any of the above (which does the same thing - see <A HREF="../../norsys/netica/Node.html#isRelated(java.lang.String, norsys.netica.Node)">isRelated</A> for singular versions), or any of the above with various modifiers appended.
  <p>Modifiers may be appended (with comma seperators) in any order to the string containing the relation.  The allowed modifiers are:
  <table CLASS="body">
  <tr><td VALIGN="top"><i>append</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">add to the list that is passed in (otherwise, that list is first emptied).</td></tr>
  <tr><td VALIGN="top"><i>union</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">add to the list that is passed in and remove all duplicates.</td></tr>
  <tr><td VALIGN="top"><i>intersection</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">reduce the passed-in list to only the nodes that are in both the original passed-in list and the relation.</td></tr>
  <tr><td VALIGN="top"><i>subtract</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">take the nodes that are in the relation away from the passed-in list.</td></tr>
  <tr><td VALIGN="top"><i>include_evidence_nodes</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Note: only relevant for "markov_boundary" and "d_connected".<br>Without it the relation list will not contain any nodes with findings.</td></tr>
  <tr><td VALIGN="top"><i>exclude_self</i></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Note: only relevant for:  "ancestors", "descendents", "connected", and "d_connected".<br>Without it the relation list will also include this node (it being generation 0).</td></tr>
  </table>
  
  <p><b>Note:</b> The definition of "ancestor", "descendent", "connected", and "d_connected" is such that a node is considered a level-0 "ancestor", "descendent", etc. of itself.  Append "exclude_self" (e.g., "ancestor,exclude_self") if you only wish to start from level-1.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm"><a href="NodeList.html">NodeList</a></span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">relatedNodes</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">a list to append the results to</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">relation</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">the relationship to search for</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 3.05 and later have this method.<br>In the C Version of the API, this function is named <b>GetRelatedNodes_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#getRelatedNodes(norsys.netica.NodeList, java.lang.String, norsys.netica.NodeList)"><CODE>Net.getRelatedNodes</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Same, but for all members of a NodeList</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#isRelated(java.lang.String, norsys.netica.Node)">isRelated</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Tests relationship of two nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getParents()">getParents</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Specialized form for 'parents'</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getChildren()">getChildren</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Specialized form for 'children'</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#getNodes()"><CODE>Net.getNodes</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Get all nodes in the net</td></tr></table><br><b>Example:</b>
  <pre CLASS="example">
  //Find all the descendants of a node, excluding the node itself.
  NodeList descendants = new NodeList (node.getNet());
  node.getRelatedNodes (descendants, "descendants,exclude_self" );</pre></DL>
<HR>

<A NAME="getStateFuncTable(int[], int[])"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>int[&nbsp;]</span>&nbsp;<span CLASS=PTFnName>getStateFuncTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentStates</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>stateTable</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                        throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Gets the state value of this node as a function of its parent nodes. The value returned is in an array which currently has only one element.
  <p>If <span CLASS="paramNm">stateTable</span> is not <span CLASS="reservedWord">null</span> it will be used to hold the returned value, rather than allocate a new array, and it will be the array reference returned.  <p>This is for discrete or discretized nodes that are deterministic.  Given a vector of states for the parents of this node, this returns the state of this node (which is functionally determined by the parent values) by looking it up in the nodes function tablse.  If the function table between this node and its parents has not yet been created, or if it is probabilistic (i.e., a CPT) rather than deterministic, this returns <A HREF="../../norsys/netica/State.html#UNDEF_STATE"> UNDEF_STATE</A>, without generating an error.
  <p>If this node is continuous, and not discretized, an exception will be thrown (use <A HREF="../../norsys/netica/Node.html#getRealFuncTable(int[], double[])">getRealFuncTable</A> instead).
  <p>The order of the states in <span CLASS="paramNm">parentStates</span> should match the order of the nodes in the list returned by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> (this will be the same order that parents were added using <A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A>).  <A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A> may be useful for that.  <span CLASS="paramNm">parentStates</span> can be <span CLASS="reservedWord">null</span> if this node has no parents.
  <p>If the node has been given a deterministic equation with <A HREF="../../norsys/netica/Node.html#setEquation(java.lang.String)">setEquation</A>, you must call <A HREF="../../norsys/netica/Node.html#equationToTable(int, boolean, boolean)">equationToTable</A> before this can be used to retrieve values (if you needed to find values without generating the whole table you would enter findings for the parents, and use <A HREF="../../norsys/netica/Node.html#calcState()">calcState</A>).
  <p>If this node is a decision node in a decision net which has been compiled, and belief propagation has been done by calling <A HREF="../../norsys/netica/Node.html#getExpectedUtils()">getExpectedUtils</A> on this node, then this method can be used to read out the table of optimal decisions under the different scenarios indicated by  <span CLASS="paramNm">parentStates</span>.
  <p>If <A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A> was used to provide this node with conditional probabilities that were all 0 or 1, getStateFuncTable can be used to retrieve the deterministic state of this node as a function of its parents.
  <p>This method ignores any findings entered in the net.
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentStates</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array of state indexes (one per parent) with which to compute our function state.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">int[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">stateTable</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array to be reused and filled with the state values.  May be <span CLASS="reservedWord">null</span>, in which case a new array will be allocated and returned.  Otherwise, it should have at least one element.  If it does not, then a new array will be allocated and returned.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 2.07 and later have this method.<br>In the C Version of the API, this function is named <b>GetNodeFuncState_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setStateFuncTable(int[], int)">setStateFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets it</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getRealFuncTable(int[], double[])">getRealFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Same, but returns real value instead of state integer</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#isDeterministic()">isDeterministic</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To check if this method is applicable</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getCPTable(int[], float[])">getCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">For nondeterministic discrete nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To create the state list passed in</td></tr></table><br><b>Example:</b>
  <pre CLASS="example">
  //Here is a convenience method taking parentStates as a comma and/or space delimited string.
  //It is from the class NodeEx which extends Node.
  public int[] getStateFuncTable (String parentStatesStr) throws NeticaException {
      return getStateFuncTable (parentStatesToIndexes (parentStatesStr), null);
  }</pre></DL>
<HR>

<A NAME="getType()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>int</span>&nbsp;<span CLASS=PTFnName>getType</span>&nbsp;(&nbsp;)
            throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns <A HREF="../../norsys/netica/Node.html#DISCRETE_TYPE"> DISCRETE_TYPE</A> if the variable corresponding to this node is discrete (digital), and <A HREF="../../norsys/netica/Node.html#CONTINUOUS_TYPE"> CONTINUOUS_TYPE</A> if it is continuous (analog).
  <p>It should be emphasized that the value returned only concerns the underlying physical variable that this node represents, not how this node acts within the net.  For example, continuous variables may be discretized by subdividing them into ranges, and discrete variables may provide real values in continuous settings.  See <A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A> for more information.
  <p>In order to determine whether a node may act discrete, call <A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A>, and if the returned value is greater than 0 then the node can act as a discrete node.
  <p>There is no API method to change the type of a node; this can only be set when the node is first created by new Node().  A continuous node may be discretized anytime, by using <A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A>.
  <p><b>WARNING:</b>  This method may return other types in the future, so check the return value completely and act appropriately if it has an unexpected value.
  <br><br><b>Version:</b><br><div CLASS="version">In version 2.07 and later.<br>In the C Version of the API, this function is named <b>GetNodeType_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To determine if a node can act discrete</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To discretize a continuous variable, so it may act discrete</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#Node(java.lang.String, int, norsys.netica.Net)">Node</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Originally sets the value that getType returns</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#isDeterministic()">isDeterministic</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Return whether a node is deterministically related to its parents</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getKind()">getKind</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Whether the node is a nature, decision, utility, constant, etc</td></tr></table><br></DL>
<HR>

<A NAME="hasTable(boolean[])"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>boolean</span>&nbsp;<span CLASS=PTFnName>hasTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;boolean[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>complete</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                 throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns <span CLASS="reservedWord">true</span> if this node has a function table or a CPT table, otherwise <span CLASS="reservedWord">false</span>.
  <p>It ignores experience tables.
  <p>If <span CLASS="paramNm">complete</span> is non-<span CLASS="reservedWord">null</span> and has length &gt; 0, then it's first element is set to indicate whether this node has a complete table (i.e., none of the entries are undefined).
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">boolean[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">complete</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">array for retrieving whether this node has a complete table or not; leave null, if this information is not needed.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 2.07 and later have this method.<br>In the C Version of the API, this function is named <b>HasNodeTable_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Create a probabilistic table (CPT)</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setStateFuncTable(int[], int)">setStateFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Create a function table for a discrete node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setRealFuncTable(int[], double)">setRealFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Create a function table for a continuous node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#deleteTables()">deleteTables</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Remove all the tables of a node</td></tr></table><br></DL>
<HR>

<A NAME="isBeliefUpdated()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>boolean</span>&nbsp;<span CLASS=PTFnName>isBeliefUpdated</span>&nbsp;(&nbsp;)
                        throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Whether the beliefs for this node have already been calculated (by belief propagation).<p>Returns <span CLASS="reservedWord">true</span> if belief updating (i.e., computing the posterior probability of node) has been done so that the beliefs at this node are consistent with the current state of the net and current findings entered into the net, otherwise it returns <span CLASS="reservedWord">false</span>.
  <p>The main use of this method is to determine if Netica will do belief propagation (which may be time consuming) the next time <A HREF="../../norsys/netica/Node.html#getBeliefs()">getBeliefs</A> or <A HREF="../../norsys/netica/Node.html#getExpectedUtils()">getExpectedUtils</A> is called with this node.
  <br><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>IsBeliefUpdated_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getBeliefs()">getBeliefs</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Updates the beliefs (if they aren't already)</td></tr></table><br></DL>
<HR>

<A NAME="isDeterministic()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>boolean</span>&nbsp;<span CLASS=PTFnName>isDeterministic</span>&nbsp;(&nbsp;)
                        throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Whether the value of this node, given its parents, is deterministic (versus probabilistic).<p>If this returns <span CLASS="reservedWord">true</span> then this node is a deterministic node, which means that:  given values for its parents, its value is determined with certainty.
  <p>There is no API method to directly set whether a node is deterministic, but setting all its conditional probabilities (i.e., CPT entries) to 0 or 1 will make a node deterministic.  Building its table just with <A HREF="../../norsys/netica/Node.html#setStateFuncTable(int[], int)">setStateFuncTable</A> or <A HREF="../../norsys/netica/Node.html#setRealFuncTable(int[], double)">setRealFuncTable</A> also will.  Note that a node with a deterministic equation can result in a non-deterministic CPT, due to uncertainties introduced in the discretization process.
  <br><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>IsNodeDeterministic_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#hasTable(boolean[])">hasTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Determine if node has any table</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To change whether a node is deterministic</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getType()">getType</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To determine if a node is for a discrete or continuous variable</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getKind()">getKind</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To determine what kind of node it is</td></tr></table><br></DL>
<HR>

<A NAME="isInNodeset(java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>boolean</span>&nbsp;<span CLASS=PTFnName>isInNodeset</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>nodeset</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                    throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns whether this node is a member of <span CLASS="paramNm">nodeset</span>.
  <p>Returns <span CLASS="reservedWord">false</span> if there is no node-set called <span CLASS="paramNm">nodeset</span> in the net containing this node.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">nodeset</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">A nodeset name.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 3.22 and later have this method.<br>In the C Version of the API, this function is named <b>IsNodeInNodeset_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#addToNodeset(java.lang.String)">addToNodeset</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To add nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#removeFromNodeset(java.lang.String)">removeFromNodeset</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To remove nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#getAllNodesets(boolean)"><CODE>Net.getAllNodesets</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Returns string listing all node-sets defined</td></tr></table><br></DL>
<HR>

<A NAME="isRelated(java.lang.String, norsys.netica.Node)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>boolean</span>&nbsp;<span CLASS=PTFnName>isRelated</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>relation</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;<A CLASS=APT HREF="../../norsys/netica/Node.html">Node</A></span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>otherNode</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                  throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>
  Tests whether this node bears the relationship <span CLASS="paramNm">relation</span> with <span CLASS="paramNm">otherNode</span>.
  <p><span CLASS="paramNm">relation</span> should be one of "parent", "child", "ancestor", "descendent", "connected", "markov_blanket", "d_connected".  These can be interpreted as "is the parent of", "is the child of", "is an ancestor of", "is a descendant of", "is conntected to", "is in the markov blanket of", and "is d_connected to", respectively.
  <p><span CLASS="paramNm">otherNode</span> may refer to this node; this would be useful, for instance, for finding nodes that bear reflexive relationships.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">relation</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">the relationship to test for</td></tr><tr><td VALIGN="top"><span CLASS="typeNm"><a href="Node.html">Node</a></span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">otherNode</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">the potentially related node</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 3.05 and later have this method.<br>In the C Version of the API, this function is named <b>IsNodeRelated_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getRelatedNodes(norsys.netica.NodeList, java.lang.String)">getRelatedNodes</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Finds all nodes bearing relationship</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#getRelatedNodes(norsys.netica.NodeList, java.lang.String, norsys.netica.NodeList)"><CODE>Net.getRelatedNodes</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Same, but for all members in a  nodelist</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getParents()">getParents</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Finds all parents of a node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getChildren()">getChildren</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Finds all children of a node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#getNodes()"><CODE>Net.getNodes</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Get all nodes in the net</td></tr></table><br><b>Example #1:</b>
  <pre CLASS="example">
  //test if node1 is a parent of node2
  if (node1.isRelated ("parent", node2)) ...</pre>
  <b>Example #2:</b>
  <pre CLASS="example">
  //test if node1 is in the markov blanket of node2
  if (node1.isRelated ("markov_blanket", node2)) ...</pre></DL>
<HR>

<A NAME="parentStatesToIndexes(java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>int[&nbsp;]</span>&nbsp;<span CLASS=PTFnName>parentStatesToIndexes</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentStateNamesStr</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                            throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Utility to convert a comma and/or space delimited string of parent state names for this node to an array of state indexes. An asterisk ('*') in place of any state name will be replaced by the index value of <A HREF="../../norsys/netica/State.html#EVERY_STATE"> EVERY_STATE</A>.
  <p><span CLASS="paramNm">parentStateNamesStr</span> should have only as many state-name entries as there are parents of this node.  Otherwise, an exception will be thrown.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentStateNamesStr</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">A comma and/or space delimited string of parent state names.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.
  </div></DL>
<HR>

<A NAME="removeFromNodeset(java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>removeFromNodeset</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>nodeset</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                       throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Removes this node from the node-set named <span CLASS="paramNm">nodeset</span>.
  <p>It is okay if this node isn't in <span CLASS="paramNm">nodeset</span> when this is called (then no action is taken).
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">nodeset</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">A nodeset name.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 3.22 and later have this method.<br>In the C Version of the API, this function is named <b>RemoveNodeFromNodeset_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#addToNodeset(java.lang.String)">addToNodeset</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">(inverse operation)  To add the nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#isInNodeset(java.lang.String)">isInNodeset</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Determines if a node is in a node-set</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#reorderNodesets(java.lang.String)"><CODE>Net.reorderNodesets</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To change the priority order of a net's node-sets</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#getAllNodesets(boolean)"><CODE>Net.getAllNodesets</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Returns string listing all node-sets defined</td></tr></table><br></DL>
<HR>

<A NAME="reorderStates(int[])"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>reorderStates</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>newOrder</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                   throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Rearranges the order of the states so that state <i>i</i> is moved to position
  <span CLASS="paramNm">newOrder</span><i>[i]</i>.  The length of <span CLASS="paramNm">newOrder</span> must be the number of states of
  this node, all its entries must be between 0 and numstates-1, and it must not contain any  duplicates.
  <p>All relevant parts of this node will be modified to reflect the change.  State names, titles, and comments will be moved, and the tables (CPT, experience, and function) will be adusted.
  <p>This function is for discrete nodes only.  It is not for continuous
  nodes, even if they have been discretized.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">newOrder</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array of state indices, representing the new arrangement of states.<br>It must contain all of the indices from 0 to numstates-1.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Since version 3.<br>In the C Version of the API, this function is named <b>ReorderNodeStates_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#addStates(int, java.lang.String, int, double)">addStates</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Adds one or more new states</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/State.html#delete()"><CODE>State.delete</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Removes a single state</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">newOrder</span> must have this many elements</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/State.html#getIndex()"><CODE>State.getIndex</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieve the new indexes of the states</td></tr></table><br></DL>
<HR>

<A NAME="reverseLink(norsys.netica.Node)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>reverseLink</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;<A CLASS=APT HREF="../../norsys/netica/Node.html">Node</A></span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentNode</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                 throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Reverses the link from <span CLASS="paramNm">parentNode</span> to this child node, so that instead it goes from this node to <span CLASS="paramNm">parentNode</span>.
  <p>This is a special method which maintains the joint probability represented by the net, which means any subsequent inference will yield the same results.  To do so, Netica may have to add or remove links which go to <span CLASS="paramNm">parentNode</span> from the parents of this node, or which go to this node from the parents of <span CLASS="paramNm">parentNode</span>.  If this is not desired then use <A HREF="../../norsys/netica/Node.html#deleteLink(int)">deleteLink</A>, followed by an <A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A> in the reverse direction.  That will change the overall joint probability, and even change the independence information represented by the net.
  <p>If links are added, the CPT tables may become very large, possibly resulting in slow behavior or an out-of-memory condition.
  <p>If it is not possible to do the reversal, an exception will be thrown, and the net will not be changed.  Reasons it might not be possible include: reversing the link would create a directed cycle, the child or parent node is not a nature node, the link is a time-delay link, the link is disconnected, or the child node has some other disconnected link.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm"><a href="Node.html">Node</a></span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentNode</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The parent whose link to us will be reversed.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>ReverseLink_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getParents()">getParents</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">See what links Netica has added or removed</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#deleteLink(int)">deleteLink</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Followed by <A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A> the other way, will result in a reversed link and a net with different independence information</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#deleteTables()">deleteTables</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Avoid overly large CPT tables caused by the reversal</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#absorbNodes(norsys.netica.NodeList)">absorbNodes</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Removes nodes, also maintaining the overall joint probability</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Environ.html#setMemoryUsageLimit(double)">setMemoryUsageLimit</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">In case this method is consuming too much memory</td></tr></table><br></DL>
<HR>

<A NAME="setConstructorClass(java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;static&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setConstructorClass</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>nodeClassNm</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                                throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the classname that Netica-J will use to independently construct Nodes.
 <p>If Netica-J has to construct a Node as a part of some operation (where you don't explicitly call a constructor), this is the class it will use.  For example, this determines the type of Nodes returned by <A HREF="../../norsys/netica/Net.html#getNode(java.lang.String)"><CODE>Net.getNode</CODE></A>.
 <p>If you would like Netica to use a class other than norsys.netica.Node, say a class of your own that extends norsys.netica.Node, then use this method to tell Netica which class to use.  The class must be available on the CLASSPATH, must extend norsys.netica.Node, and must have a default (parameterless) constructor; otherwise a <span CLASS="classType"> NeticaException</span> will be thrown.
 <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">nodeClassNm</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The name of a class, available on the CLASSPATH, that is an instance or extension of norsys.netica.Node</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.
 </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getConstructorClass()">getConstructorClass</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieve the name of the current Class used for this purpose</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#setConstructorClass(java.lang.String)"><CODE>Net.setConstructorClass</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Same for Nets</td></tr></table><br><b>Example:</b>
 <pre CLASS="example">
 Node.setConstructorClass("com.myCompany.myProject.MyNode");
 <div CLASS=desc>where ../com/myCompany/myProject/MyNode.java looks like:</div>
 /* 
  * MyNode.java
  *
  * Example of how to extend norsys.netica.Node.
  *<Z>/
 package com.myCompany.myProject;
 import norsys.netica.*;
 
 public class MyNode extends Node {
     int i = 0; // your fields
 
     //------------------------------------------------------------ constructors
     public MyNode (String name, int num_states, Net parentNet) throws NeticaException {
         super (name, num_states, parentNet);
         i = 1;
     }
 
     public MyNode (String name, String stateNames, Net parentNet) throws NeticaException {
         super (name, stateNames, parentNet);
         i = 2;
     }
 
     public MyNode() throws NeticaException { 
         super ();
     }
 }</pre></DL>
<HR>

<A NAME="setCPTable(int[], float[])"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setCPTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentStates</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;float[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>cpTable</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the probabilities for each state of this node, conditioned on its parent nodes.<p>The purpose of this method is to build the conditional probability table (CPT) of this node, which provides a probability distribution over the states of this node for each possible configuration of parent states (i.e., parent condition).  Each call sets the conditional probabilities of this node for the situation where its parents have the states indicated by the vector <span CLASS="paramNm">parentStates</span>.  The length of <span CLASS="paramNm">parentStates</span> must be the number of parents of this node, and each of its entries provides a state for the corresponding parent.  The length of the <span CLASS="paramNm">cpTable</span> array must be the number of states of this node, and consist of the conditional probabilities:
  <p>&nbsp;&nbsp;P (this node = state0  | parents take on <span CLASS="paramNm">parentStates</span>)
  <p>&nbsp;&nbsp;P (this node = state1  | parents take on <span CLASS="paramNm">parentStates</span>)
  <p>&nbsp;&nbsp;	      <b>...</b>
  <p>&nbsp;&nbsp;P (this node = stateN  | parents take on <span CLASS="paramNm">parentStates</span>)
  <p>The order of the states in <span CLASS="paramNm">parentStates</span> should match the order of the nodes in the list returned by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> (this will be the same order that parents were added using <A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A>).  <A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A> may be useful for that.  <span CLASS="paramNm">parentStates</span> can be <span CLASS="reservedWord">null</span> if this node has no parents.
  <p>If any entry of <span CLASS="paramNm">parentStates</span> is <A HREF="../../norsys/netica/State.html#EVERY_STATE"> EVERY_STATE</A> then it applies to all possible values of the corresponding parent.  More than one entry of <span CLASS="paramNm">parentStates</span> may be <A HREF="../../norsys/netica/State.html#EVERY_STATE"> EVERY_STATE</A>, in which case all the probabilities of their cartesian product will be set to <span CLASS="paramNm">cpTable</span>, as you would expect (e.g., see the makeProbsUniform example below).
  
  <p>If this node has many parents (i.e., the product of their number of states is large) then the probability table will be large, and your system may run out of memory, in which case an exception will be thrown.
  <p>After changing a node's probabilities, its net must be (re)compiled before calling <A HREF="../../norsys/netica/Node.html#getBeliefs()">getBeliefs</A> on any node in the net (although a full recompile isn't necessary, so it will proceed very quickly).
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentStates</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The indexes of the parent states.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">float[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">cpTable</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The probabilities in the same order as our states.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In versions 1.33 and earlier, "<A HREF="../../norsys/netica/State.html#EVERY_STATE"> EVERY_STATE</A>" was called "<span>WILDCARD_STATE</span>".<br>In the C Version of the API, this function is named <b>SetNodeProbs_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getCPTable(int[], float[])">getCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieve values</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setStateFuncTable(int[], int)">setStateFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Build the table for a deterministic node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setExperTable(int[], double)">setExperTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Associate a degree of experience with the probabilities</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#reviseCPTsByFindings(norsys.netica.NodeList, double)">reviseCPTsByFindings</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Revise the probabilities using the case currently entered</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#reviseCPTsByCaseFile(norsys.netica.Streamer, norsys.netica.NodeList, double)">reviseCPTsByCaseFile</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Revise the probabilities using a file of cases</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#fadeCPTable(double)">fadeCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Adjust the probabilities for a changing world</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To create the state list passed in</td></tr></table><br><b>Example #1:</b>
  <pre CLASS="example">
  Suppose you have a node with 4 states and it has two parents.  
  Parent1 has 2 states (say 'true' and 'false').
  Parent2 has 3 states (say 'red', 'green', and 'blue'). 
  You want to assign the following CPTable to node:
  
                        |  Probabilities that node is in 
      parent1  parent2  |  state1  state2  state3  state4  
      -------  ------   |  ------  ------  ------  ------
      true     red      |  0.0     0.8     0.2     0.0
      true     green    |  0.1     0.7     0.2     0.0
      true     blue     |  0.1     0.1     0.1     0.7
      false    red      |  0.0     0.0     0.0     1.0
      false    green    |  0.0     0.0     0.2     0.8
      false    blue     |  1.0     0.0     0.0     0.0
  
    Then this is how you might proceed:
    
    //setting row1 of the CPTable, for parent1=true, parent2=red
    int[] parentStates = int[2];
    parentStates[0] = 0;
    parentStates[1] = 0;
    float[] probsRow1 = {0.0F, 0.8F, 0.2F, 0.0F};
    node.setCPTable (parentStates, probsRow1);
  
    //setting row2 of the CPTable, for parent1=true, parent2=green
    parentStates[0] = 0;
    parentStates[1] = 1;
    float[] probsRow2 = {0.1F, 0.7F, 0.2F, 0.0F};
    node.setCPTable (parentStates, probsRow2);
    
    //setting row3 of the CPTable, for parent1=true, parent2=blue
    parentStates[0] = 0;
    parentStates[1] = 2;
    float[] probsRow3 = {0.1F, 0.1F, 0.1F, 0.7F};
    node.setCPTable (parentStates, probsRow3);
    
    //setting row4 of the CPTable, for parent1=false, parent2=red
    parentStates[0] = 1;
    parentStates[1] = 0;
    float[] probsRow4 = {0.0F, 0.0F, 0.0F, 1.0F};
    node.setCPTable (parentStates, probsRow4);
    
    ... and so on, for the remaining two rows ...</pre>
  <b>Example #2:</b>
  <pre CLASS="example"><div CLASS=desc>The following method is available in NodeEx.java:</div>
  /** 
   *  Gives the passed node a uniform conditional probability distribution
   *  (i.e., all the probabilities the same).
   *  @param node the node to modify
   *<Z>/
  static void makeProbsUniform (Node node) throws NeticaException {
      int numStates  = node.getNumStates();
      int numParents = node.getParents().size();
      float[] uniform = new float[numStates];
      int[]   pstates = new int[numParents];
      for (int st = 0;  st &lt; numStates;   ++st)  uniform[st] = 1.0F / numStates;
      for (int pn = 0;  pn &lt; numParents;  ++pn)  pstates[pn] = Node.EVERY_STATE;
      node.setCPTable (pstates, uniform);
  }</pre>
  <b>Example #3:</b>
  <pre CLASS="example"><div CLASS=desc>The following method is available in NodeEx.java:</div>
  /** 
   * Sets all the conditional probabilities of a given node based on a 2-D array of probabilities.
   * You could use this function in combination with getNodeAllProbs (see  getCPTable
   * to temporarily save probability tables.
   * The 1st dimension of the array passed must be the size of cartesian product
   * of the states of each parent of node, and must be in "odometer order".
   * See NodeListEx.nextStates() for an explanation of the odometer order of 
   * all possible parent states. 
   *
   * @param node  is the node whose CPT we are setting
   * @param probs is an array of probabilities, the first dimension being of size equal to 
   *	             the size of cartesian product of the states of each parent of node. 
   *              The second dimension is the number of states of node.
   *              i.e., float[][] probs = 
   *                      new float[(int)NodeListEx.sizeCartesianProduct (node.getParents()]
   *                               [node.getNumStates()];
   *<Z>/
  static void setNodeAllProbs (Node node, float[][] probs) throws NeticaException {
      NodeList parents = node.getParents();
      int[] parentStates = new int[parents.size()]; //all initially zero
      int probSet = 0;
      while (true){
          node.setCPTable (parentStates, probs[probSet++]);
          if (NodeListEx.nextStates (parentStates, parents))  break;
      }
  }</pre></DL>
<HR>

<A NAME="setCPTable(java.lang.String, float[])"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setCPTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentStateNames</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;float[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>cpTable</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>This does the same as <A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable(int[], float[])</A> except that it takes the parent states as a string rather than as an integer array.  For additional documentation, see <A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable(int[], float[])</A>.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentStateNames</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">A comma and/or space delimited set of parent states, one for each parent.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">float[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">cpTable</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The probabilities in the same order as our states.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>SetNodeProbs_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getCPTable(java.lang.String, float[])">getCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves values</td></tr></table><br></DL>
<HR>

<A NAME="setCPTable(float[])"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setCPTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;float[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>cpTable</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the entire CPTable of this node in one call.
  <p><span CLASS="paramNm">probs</span> is a 1-D array representation of the entire CPTable.  See the example below for how to arrange the probabilities.  Basically, the rule is that you vary the largest indexed parent's states most rapidly, then the second largest indexed parent's states, and so on.  This is the same arrangement as is returned by the inverse method <A HREF="../../norsys/netica/Node.html#getCPTable(float[])">getCPTable</A>.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">float[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">probs</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The entire CPTable as a 1-D array.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 3 and later have this method.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getCPTable(float[])">getCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves it</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">getCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Set values of CPTable one row at a time</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getCPTable(java.lang.String, float[])">getCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves values</td></tr></table><br><b>Example:</b>
  <pre CLASS="example">
  Suppose you have a node with 4 states and it has two parents.  
  Parent1 has 2 states (say 'true' and 'false').
  Parent2 has 3 states (say 'red', 'green', and 'blue'). 
  You want to assign the following CPTable to node:
  
                        |  Probabilities that node is in 
      parent1  parent2  |  state1  state2  state3  state4  
      -------  ------   |  ------  ------  ------  ------
      true     red      |  0.0     0.8     0.2     0.0
      true     green    |  0.1     0.7     0.2     0.0
      true     blue     |  0.1     0.1     0.1     0.7
      false    red      |  0.0     0.0     0.0     1.0
      false    green    |  0.0     0.0     0.2     0.8
      false    blue     |  1.0     0.0     0.0     0.0
  
    Then this is how you might proceed, using this method
    
    float[] probs = {0.0F, 0.8F, 0.2F, 0.0F,
                     0.1F, 0.7F, 0.2F, 0.0F,
                     0.1F, 0.1F, 0.1F, 0.7F,
                     0.0F, 0.0F, 0.0F, 1.0F,
                     0.0F, 0.0F, 0.2F, 0.8F,
                     1.0F, 0.0F, 0.0F, 0.0F};
  
    node.setCPTable (probs);</pre></DL>
<HR>

<A NAME="setEquation(java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setEquation</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>eqn</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                 throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the equation giving the probability of this node conditioned on its parent nodes, or the value of this node as a function of its parents.
  <p>The equation can be deterministic, so that it specifies a value for this node, given values for its parents (i.e., it expresses this node as a function of its parents).  Or, it can be probabilistic, so that it provides a probability for each of this node's values (i.e., a probability distribution), as a function of its parents.
  <p>For information on Netica equations, see the "Equation" chapter of Netica Application's onscreen help.
  <p><b>WARNING:</b>  Setting a node's equation does not modify its CPT table (which is what is used for inference in a compiled net).  To modify the CPT table so that it reflects the new equation, use <A HREF="../../norsys/netica/Node.html#equationToTable(int, boolean, boolean)">equationToTable</A>.
  <p>To remove a node's equation, pass <span CLASS="reservedWord">null</span> or the empty string for <span CLASS="paramNm">eqn</span>.
  
  <p>There is no restriction on the length or complexity of the equation.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">eqn</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The equation string to be assigned.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 1.30 and later have this method.<br>In the C Version of the API, this function is named <b>SetNodeEquation_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getEquation()">getEquation</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves value</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#equationToTable(int, boolean, boolean)">equationToTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Required to convert the equation to a CPT table for inference</td></tr></table><br></DL>
<HR>

<A NAME="setExperTable(int[], double)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setExperTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentStates</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;double</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>experience</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                   throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the experience of this node as a function of its parent nodes.<p>This is to associate a degree of experience with each belief vector of this node's conditional probability table.  It sets the amount of experience for the condition described by <span CLASS="paramNm">parentStates</span> (which provides a value for each parent) to <span CLASS="paramNm">experience</span>. 
  <p>The order of the states in <span CLASS="paramNm">parentStates</span> should match the order of the nodes in the list returned by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> (this will be the same order that parents were added using <A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A>).  <A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A> may be useful for that.  <span CLASS="paramNm">parentStates</span> can be <span CLASS="reservedWord">null</span> if this node has no parents.
  <p>If any entry of <span CLASS="paramNm">parentStates</span> is <A HREF="../../norsys/netica/State.html#EVERY_STATE"> EVERY_STATE</A> then it applies to all possible values of the corresponding parent (see&nbsp;<A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A>).
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentStates</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array of state indexes (one per parent).</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">double</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">experience</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The experience value to be assigned to this node when the parents are in the given states.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In versions 1.33 and earlier, "<A HREF="../../norsys/netica/State.html#EVERY_STATE"> EVERY_STATE</A>" was called "<span>WILDCARD_STATE</span>".<br>In the C Version of the API, this function is named <b>SetNodeExperience_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getExperTable(int[], double[])">getExperTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves values</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#reviseCPTsByFindings(norsys.netica.NodeList, double)">reviseCPTsByFindings</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Increments experience</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#reviseCPTsByCaseFile(norsys.netica.Streamer, norsys.netica.NodeList, double)">reviseCPTsByCaseFile</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets experience to measure the number of relevant cases</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#fadeCPTable(double)">fadeCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Decreases experience, and smoothes the probabilities</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets corresponding CPT table entry</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setExperTable(double)">setExperTable(double)</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets the entire experience table to a uniform value</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To create the state list passed in</td></tr></table><br><b>Example:</b>
  <pre CLASS="example">
  //Here is a convenience method taking parentStates as a comma and/or space delimited string.
  //It is from the class NodeEx which extends Node.
  public void setExperTable (String parentStatesStr, double experience) throws NeticaException {
      setExperTable (parentStatesToIndexes (parentStatesStr), experience);
  }</pre></DL>
<HR>

<A NAME="setExperTable(double)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setExperTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;double</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>experience</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                   throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the experience of this node as a function of its parent nodes.
  <p> This is a convenience method that sets every entry of the experience table to a single value.  It is equivalent to calling <A HREF="../../norsys/netica/Node.html#setExperTable(int[], double)">setExperTable(int[], double)</A> where the int[] has all of its elements set to State.EVERY_STATE.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">double</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">experience</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The experience value to be assigned to all the entries in the experience table.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Since version 3.<br>In the C Version of the API, this function is named <b>SetNodeExperience_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setExperTable(int[], double)">setExperTable(int[], double)</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets value for part of the experience table</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getExperTable(int[], double[])">getExperTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves values</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#reviseCPTsByFindings(norsys.netica.NodeList, double)">reviseCPTsByFindings</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Increments experience</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#reviseCPTsByCaseFile(norsys.netica.Streamer, norsys.netica.NodeList, double)">reviseCPTsByCaseFile</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets experience to measure the number of relevant cases</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#fadeCPTable(double)">fadeCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Decreases experience, and smoothes the probabilities</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets corresponding CPT table entry</td></tr></table><br></DL>
<HR>

<A NAME="setInputName(int, java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setInputName</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>inputIndex</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>inputName</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                  throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the name of this node's input (i.e., link).<p>Names the link entering this node from its <span CLASS="paramNm">inputIndex</span>th parent to be <span CLASS="paramNm">inputName</span>.
  <p><span CLASS="paramNm">inputIndex</span> corresponds to the ordering of the parents obtained by  <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> (with the first parent having <span CLASS="paramNm">inputIndex</span> = 0).  The reason that an index number is passed instead of the actual parent, is because the link may not have a parent node (i.e., it is "disconnected"), or there may be more than 1 link from the same parent to this node.
  <p><span CLASS="paramNm">inputName</span> must be a legal IDname, which means it  must have <A HREF="../../norsys/netica/General.html#NAME_MAX"> NAME_MAX</A> (30) or fewer characters, all of which are letters, digits or underscores, and it must start with a letter.
  <p>To remove the name of a link, pass <span CLASS="reservedWord">null</span> (not the empty string) for <span CLASS="paramNm">inputName</span>.
  <p><span CLASS="paramNm">inputName</span> must be different from the name of any other links entering this node (by case-sensitive comparison, and must be different from the names of any parents of this node which are connected to this node by an unnamed link.
  <p>Input names are used to document what each link means, local to the node, which is especially important if the link is disconnected, or if its parents are continuously being switched.  They are also useful as local parameters in equations, instead of using the names of parent nodes, so the equation stays valid even if the parents change.
  <p>When links are first created, they are unnamed, and remain so until this method is called, or until they are disconnected from the parent node (in which case they take on the name of the parent).  It is possible to name some of the links entering a node, and leave the rest unnamed.  All disconnected links are named.
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">inputIndex</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The index of the desired input Node.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">inputName</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The the desired new name to assign this input link.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>SetNodeInputName_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getInputName(int)">getInputName</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves value</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getInputIndex(java.lang.String)">getInputIndex</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves the index given the name</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getParents()">getParents</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Gets the actual parents of the links (e.g., to find their names or determine their numbering)</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#switchParent(int, norsys.netica.Node)">switchParent</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Connects the "input" to a parent node</td></tr></table><br></DL>
<HR>

<A NAME="setKind(int)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setKind</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>kind</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
             throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets whether this node is a nature, decision, utility or constant node.
  <p><span CLASS="paramNm">kind</span> must be one of:
  <table CLASS="body">
  <tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#NATURE_NODE"> NATURE_NODE</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Bayes nets are composed only of this type (and constant nodes)<br>This is a "chance" or "deterministic" node of an influence diagram</td></tr>
  <tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#DECISION_NODE"> DECISION_NODE</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Indicates a variable that can be controlled<br>This is a "decision" node of an influence diagram</td></tr>
  <tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#UTILITY_NODE"> UTILITY_NODE</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">A variable to maximize the expected value of<br>This is a "value" node of an influence diagram</td></tr>
  
  <tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#CONSTANT_NODE"> CONSTANT_NODE</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">A fixed parameter, useful as an equation constant<br>When its value changes, equations should be reconverted to CPT tables, and maybe the net recompiled</td></tr>
  </table>
  Nodes of one kind can usually be transformed to another at any time, but certain transformations are not allowed.  Calling setKind with a disallowed transformation will result in no changes, and a suitable error report will be generated.  An example of a disallowed transformation is a non-deterministic node being transformed into a utility node.
  <p>You cannot use setKind to change a node to kind <A HREF="../../norsys/netica/Node.html#DISCONNECTED_NODE"> DISCONNECTED_NODE</A>.  Nodes of that kind are created automatically when <A HREF="../../norsys/netica/Node.html#switchParent(int, norsys.netica.Node)">switchParent</A> is called with <span CLASS="reservedWord">null</span> for the new parent.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">kind</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The new kind.</td></tr></table><br><b>Version:</b><br><div CLASS="version">In versions 1.09 and earlier, <A HREF="../../norsys/netica/Node.html#CONSTANT_NODE"> CONSTANT_NODE</A> was called <span>ASSUME_NODE</span>.<br>In the C Version of the API, this function is named <b>SetNodeKind_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getKind()">getKind</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves value</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#Node(java.lang.String, int, norsys.netica.Net)">Node</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets whether node is for a discrete or continuous variable</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#switchParent(int, norsys.netica.Node)">switchParent</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To change a node to kind <A HREF="../../norsys/netica/Node.html#DISCONNECTED_NODE"> DISCONNECTED_NODE</A></td></tr></table><br></DL>
<HR>

<A NAME="setLevels(double[])"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setLevels</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;double[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>levels</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
               throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the levels list of this node to <span CLASS="paramNm">levels</span>.
  <p>The levels list is a list of real numbers used by Netica to translate from a real value of a continuous node to a discrete state, or from a state of a discrete node to a real value.  That way a continuous node can act discrete (called "discretization"), or a discrete node can provide real-valued numbers.
  <p>If the underlying variable is continuous, we may want to discretize it for some operations.  For example, we may divide all possible masses of some object into 3 ranges:  0 to 0.1 kg,  0.1 to 10 kg,  and greater than 10 kg.  For that we would use the levels list:   [0, 0.1, 10, <A HREF="../../norsys/netica/Environ.html#INFINITY"> INFINITY</A>].
  <p>Conversely, if it is discrete, we may want a mapping from its state (represented as an integer), to a measurable value.  For example, a drill may have 3 speeds (2.5 rps, 5 rps and 10 rps) as well as off.  We could use a 4-state discrete node to represent the drill speed, with the levels list  [0, 2.5, 5, 10].  Or milk may be available in containers of size 0.375, l, and 2 liters.
  
  <p>Since the usage of levels is a little different for each type of node, each is discussed separately:
  <p>
  <p><b><!-- 22 -->this node is continuous:</b>   (<A HREF="../../norsys/netica/Node.html#getType()">getType</A> would return <A HREF="../../norsys/netica/Node.html#CONTINUOUS_TYPE"> CONTINUOUS_TYPE</A>)
  
  <p><span CLASS="paramNm">levels</span> must contain <span CLASS="paramNm">numStates</span> + 1 entries, and must monotonically ascend or descend (it is okay to have adjacent entries equal to create point-valued "ranges").
  <p>The first and last entries of the levels list provide a bound on the lowest and highest values the node can take on, but they may be <A HREF="../../norsys/netica/Environ.html#INFINITY"> INFINITY</A>  or  -<A HREF="../../norsys/netica/Environ.html#INFINITY"> INFINITY</A>.
  <p>Once this node has been given the levels list, Netica can translate a continuous value <span CLASS="paramNm">val</span> for the node to a discrete state <span CLASS="paramNm">st</span>, by choosing <span CLASS="paramNm">st</span> so that:
  
  <p>&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="code">levels [<span CLASS="paramNm">st</span>]   &lt;=  <span CLASS="paramNm">val</span>   &lt;   levels [<span CLASS="paramNm">st</span> + 1]</span>       (if levels ascends)  or
  <br>&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="code">levels [<span CLASS="paramNm">st</span>]  &gt;   <span CLASS="paramNm"> val</span>   &gt;=  levels [<span CLASS="paramNm">st</span> + 1]</span>       (if levels descend)
  <br>A discrete state <span CLASS="paramNm">st</span> can also be translated to the range:
  <br>&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="code">[levels[<span CLASS="paramNm">st</span>], levels[<span CLASS="paramNm">st</span> + 1])</span>       (if levels ascends)  or
  <br>&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="code">[levels[<span CLASS="paramNm">st</span> + 1], levels[<span CLASS="paramNm">st</span>])</span>       (if levels descend)
  
  <p>
  <p><b><!-- 22 -->this node is discrete:</b>   (<A HREF="../../norsys/netica/Node.html#getType()">getType</A> would return <A HREF="../../norsys/netica/Node.html#DISCRETE_TYPE"> DISCRETE_TYPE</A>)
  <p>There must be one entry in <span CLASS="paramNm">levels</span> for each state of this node.  The value passed for <span CLASS="paramNm">numStates</span> must be the number of states of the node (i.e., the value returned by <A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A>).  There is no constraint on the ordering of <span CLASS="paramNm">levels</span>.
  
  <p>Once this node has been given the levels list, Netica can convert a discrete state <span CLASS="paramNm">st</span> to a real-valued number <span CLASS="paramNm">val</span>, using:
  
  <p>&nbsp;&nbsp;<span CLASS="code"><span CLASS="paramNm">val</span> = levels [<span CLASS="paramNm">st</span>]</span>
  
  <p>A real-number value <span CLASS="paramNm">val</span> can also be translated to a discrete state <span CLASS="paramNm">st</span> by choosing <span CLASS="paramNm">st</span> so that:  <span CLASS="paramNm">val</span> = levels [<span CLASS="paramNm">st</span>].  If there is no such <span CLASS="paramNm">st</span>, then a legal translation cannot be made, but sometimes you can request Netica to approximate by choosing <span CLASS="paramNm">st</span> so that:
  
  <p>&nbsp;&nbsp;<span CLASS="code">| <span CLASS="paramNm">val</span> - levels [<span CLASS="paramNm">st</span>] |</span>   is minimized.
  
  
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">double[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">levels</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The new levels to be assigned to all this node's states.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>SetNodeLevels_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getLevels()">getLevels</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves values</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#Node(java.lang.String, int, norsys.netica.Net)">Node</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Must be called with <span CLASS="paramNm">numStates</span> = 0 to make continuous node</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#EnterNodeValue(double)">EnterNodeValue</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Uses discretization to convert to state finding</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#equationToTable(int, boolean, boolean)">equationToTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Uses discretization to handle continuous values in the table</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getExpectedValue(double[])">getExpectedValue</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Uses discretization or real values to calculate mean and standard deviation</td></tr></table><br><b>Example #1:</b>
  <pre CLASS="example">
  // Here we make a continuous node and then discretize it into 3 states.
  //
  Node node = new Node ("n1", 0, net);       // must pass 0 for num_states to create a node 
                                                for a continuous variable
  double[] levels = new double[4];           // 1 more than the number of desired states
  levels[0] =  0.0;                          // the first range is 0 to 0.1
  levels[1] =  0.1;
  levels[2] = 10.0;
  levels[3] = Environ.INFINITY;
  node.setLevels(levels);                    // discretizes to 3 states
  node.setStateNames("low, medium, high");   // naming the states is optional</pre>
  <b>Example #2:</b>
  <pre CLASS="example">
  // Here we make a 3-state discrete node and then give it
  // levels to provide real values to its children.
  //
  Node node = new Node ("voltSwitch", 3, net);  // discrete, with 3 states
  double[] levels = new double[3];         // 1 element for each state
  levels[0] =  0.0;
  levels[1] = -3.5;                        // state 1 gives -3.5
  levels[2] =  5.5;
  node.setLevels(levels);                  // set the levels
  node.setStateNames("off, reverse, forward");   // naming the states is optional</pre></DL>
<HR>

<A NAME="setRealFuncTable(int[], double)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setRealFuncTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentStates</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;double</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>funcValue</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                      throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the real value of this (continuous) deterministic node as a function of its parent nodes.<p>This is for deterministic nodes that are continuous or have been given real levels (e.g., by <A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A>).  Deterministic nodes can be expressed as a function of their parent nodes, and that function can be in the form of a table.  The purpose of setRealFuncTable is to build that table.  It adds an entry to the table by telling Netica that when each parent has the state indicated in the vector <span CLASS="paramNm">parentStates</span>, the value of this node is <span CLASS="paramNm">funcValue</span>.
  <p>The order of the states in <span CLASS="paramNm">parentStates</span> should match the order of the nodes in the list returned by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> (this will be the same order that parents were added using <A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A>).  <A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A> may be useful for that.  <span CLASS="paramNm">parentStates</span> can be <span CLASS="reservedWord">null</span> if this node has no parents.
  <p>If any entry of <span CLASS="paramNm">parentStates</span> is <A HREF="../../norsys/netica/State.html#EVERY_STATE"> EVERY_STATE</A> then it applies to all possible values of the corresponding parent (see&nbsp;<A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A>).
  <p>If node has many parents (i.e., the product of their number of states is large) then the function table will be large, and your system may run out of memory.
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentStates</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array of state indexes (one per parent).</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">double</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">funcValue</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The value to be assigned to this node when the parents are in the given states.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 2.07 and later have this method.<br>In versions 1.33 and earlier, "<A HREF="../../norsys/netica/State.html#EVERY_STATE"> EVERY_STATE</A>" was called "<span>WILDCARD_STATE</span>".<br>In the C Version of the API, this function is named <b>SetNodeFuncReal_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getRealFuncTable(int[], double[])">getRealFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves values</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setStateFuncTable(int[], int)">setStateFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Same, but builds state integer tables instead of real-valued tables</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To use instead if this node isn't deterministic</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To create the state list passed in</td></tr></table><br><b>Example #1:</b>
  <pre CLASS="example">
  
  /** 
   *  For continuous nodes that are a deterministic function of their
   *  parents' states, this method can be used to set the function table in one
   *  call, rather than repeatedly calling setRealFuncTable().
   *  The array passed must be the size of cartesian product of the states of each 
   *  parent of node. It contains the values of this node when the parents are 
   *  in the corresponding index'th odometer configuration.  
   *  See NodeListEx.nextStates() for an explanation of  the odometer order 
   *  of all possible parent states. 
   *  The following line is useful for declaring value[]:
   *  double[] value = new double[ NodeListEx.sizeCartesianProduct (node.getParents()) ];
   * 
   *  This method is in NodeEx.java.
   *
   *  @param node      the node of interest
   *  @param value     the array of values of this node, one entry per permutation
   *                   of parent states in "odometer order".
  *<Z>/
  static void setNodeFuncReal (Node node, double[] value){
      NodeList parents = node.getParents();
      int[] parentStates = new int[parents.size()]; //all initially zero
      int probSet = 0;
      while (true){
          node.setRealFuncTable(parentStates, value[probSet++]);
          if (NodeListEx.nextStates (parentStates, parents))  break;
      }
  }</pre>
  <b>Example #2:</b>
  <pre CLASS="example"><div CLASS=desc>The following method is available in NodeEx.java which extends Node.java:</div>
  //Here is a convenience method taking parentStates as a comma and/or space delimited string.
  public void setRealFuncTable (String parentStatesStr, double funcValue) throws NeticaException {
      setRealFuncTable (parentStatesToIndexes (parentStatesStr), funcValue);
  }</pre></DL>
<HR>

<A NAME="setStateFuncTable(int[], int)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setStateFuncTable</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>parentStates</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>funcState</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                       throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the state value of this (discrete or discretized) deterministic node as a function of its parent nodes.<p>For deterministic nodes that are discrete or discretized.  Deterministic nodes can be expressed as a function of their parent nodes, and that function can be in the form of a table.  The purpose of setStateFuncTable is to build that table.  It adds an entry to the table by telling Netica that when each parent has the state indicated in the vector <span CLASS="paramNm">parentStates</span>, the state of this node is <span CLASS="paramNm">funcState</span>.
  <p>The order of the states in <span CLASS="paramNm">parentStates</span> should match the order of the nodes in the list returned by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> (this will be the same order that parents were added using <A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A>).  <A HREF="../../norsys/netica/NodeList.html#mapStateList(int[], norsys.netica.NodeList, norsys.netica.NodeList)">mapStateList</A> may be useful for that.  <span CLASS="paramNm">parentStates</span> can be <span CLASS="reservedWord">null</span> if this node has no parents.
  <p>If any entry of <span CLASS="paramNm">parentStates</span> is <A HREF="../../norsys/netica/State.html#EVERY_STATE"> EVERY_STATE</A> then it applies to all possible values of the corresponding parent (see&nbsp;<A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A>).
  <p>If this node has many parents (i.e., the product of their number of states is large) then the function table will be large, and your system may run out of memory.
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int[]</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">parentStates</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">An array of state indexes (one per parent).</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">funcState</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The state value to be assigned to this node when the parents are in the given states.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 2.07 and later have this method.<br>In versions 1.33 and earlier, "<A HREF="../../norsys/netica/State.html#EVERY_STATE"> EVERY_STATE</A>" was called "<span>WILDCARD_STATE</span>".<br>In the C Version of the API, this function is named <b>SetNodeFuncState_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getStateFuncTable(int[], int[])">getStateFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves values</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setRealFuncTable(int[], double)">setRealFuncTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Same, but builds real-valued tables instead of discrete tables</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setCPTable(int[], float[])">setCPTable</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To use instead if this node isn't deterministic</td></tr></table><br><b>Example #1:</b>
  <pre CLASS="example">
  /** 
   * For discrete or discretized nodes that are a deterministic function of their
   * parents' states, this method can be used to set the function table in one
   * call, rather than repeatedly calling setStateFuncTable().
   * The array passed must be the size of cartesian product of the states of each 
   * parent of node. It contains state indices of this state, each entry representing
   * the state that this node is in when the parents are in the corresponding index'th
   * odometer configuration.  See NodeListEx.nextStates() for an explanation of 
   * the odometer order of all possible parent states. 
   * The following line is useful for declaring value[]:
   * int[] value = new int[ NodeListEx.sizeCartesianProduct (node.getParents()) ];
   * 
   * This method is in NodeEx.java.
   * 
   * @param node      the node of interest
   * @param value     the array of states of this node, one entry per permutation
   *                  of parent states in "odometer order".
   *<Z>/
  static void setNodeFuncState (Node node, int[] value){
      NodeList parents = node.getParents();
      int[] parentStates = new int[parents.size()]; //all initially zero
      int probSet = 0;
      while (true){
          node.setStateFuncTable(parentStates, value[probSet++]);
          if (NodeListEx.nextStates (parentStates, parents))  break;
      }
  }</pre>
  <b>Example #2:</b>
  <pre CLASS="example">
  // This doesn't use setStateFuncTable, but it is useful for setting
  // parentStates.<div CLASS=desc>The following method is defined in NodeListEx.java:</div>
  /** 
   *  This  cycles through all possible configurations (i.e., elements of the cartesian
   *  product) of states, odometer style, with the last state changing fastest.
   *  states is a list of node states, one for each node of nodeList.
   *  It returns 'true' when all the configurations have been examined (i.e., when it
   *  "rolls over" to all zeros again).
   *  Don't forget to initialize states before calling it the first time (usually 
   *    to all zeros).
   *  @param states  A set of state indices, one per node in nodeList, and in the same 
   *                 order as the nodes in nodeList.
   *  @param nodeList  A set of nodes, whose states are to be cycled through.
   *<Z>/
  public static boolean nextStates (int[] states, NodeList nodeList) throws NeticaException {
      int n;
      for (n = nodeList.size() - 1;  n &gt;= 0;  n--){
          Node node = (Node) nodeList.get(n);
          if (++states[n] &lt; node.getNumStates())
              return false;
           states[n] = 0;
      }
      return true;
  }</pre>
  <b>Example #3:</b>
  <pre CLASS="example">
  //Here is a convenience method taking parentStates as a comma and/or space delimited string.
  public void setStateFuncTable (String parentStatesStr, int funcState) throws NeticaException {
      setStateFuncTable (parentStatesToIndexes (parentStatesStr), funcState);
  }</pre></DL>
<HR>

<A NAME="setStateNames(java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setStateNames</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>names</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                   throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Names the states of this node using the list of names <span CLASS="paramNm">names</span>.
  <p>The names must be separated by commas and/or whitespace (i.e., spaces, tabs or newlines).  It is okay if there is an extra separator at the end.  The number of names must be the number that would be returned by <A HREF="../../norsys/netica/Node.html#getNumStates()">getNumStates</A>.
  <p>Each name must be a legal IDname, which means it  must have <A HREF="../../norsys/netica/General.html#NAME_MAX"> NAME_MAX</A> (30) or fewer characters, all of which are letters, digits or underscores, and it must start with a letter.  No two states of a node may have the same name.  To avoid these restrictions, you can give the states titles instead; see <A HREF="../../norsys/netica/General.html#setTitle(java.lang.String)"><CODE>State.setTitle</CODE></A>.
  <p>It is not required that a node's states be named.  If you pass <span CLASS="reservedWord">null</span> (not the empty string) for <span CLASS="paramNm">names</span>, it will remove all the state names for this node.
  <p>Discretized continuous nodes may have their states named, as well as regular discrete nodes.
  
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">names</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">A comma and/or space delimited set of state names, in index order.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 2.10 and later have this method.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/General.html#setName(java.lang.String)"><CODE>State.setName</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets name of one state at a time</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/General.html#getName()"><CODE>State.getName</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves a single state name</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/General.html#setTitle(java.lang.String)"><CODE>State.setTitle</CODE></A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Doesn't have the restrictions of a name</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#Node(java.lang.String, int, norsys.netica.Net)">Node(String, int, Net)</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Constructor sets the number of states to start with</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#Node(java.lang.String, java.lang.String, norsys.netica.Net)">Node(String, String, Net)</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Constructor sets the state names as well</td></tr></table><br><b>Example:</b>
  <pre CLASS="example">
  // Here is how you might make a new node with the 2 states
  // "true" and "false".
  Node node = New Node ("n1", 2, net);  // make new node with 2 states
  node.setStateNames ("true, false");
  //
  // Of course, you could do this more easily with the Node constructor
  // that sets the state names at construction time
  Node node = New Node ("n1", "true, false", net);</pre></DL>
<HR>

<A NAME="state(int)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype><A CLASS=APT HREF="../../norsys/netica/State.html">State</A></span>&nbsp;<span CLASS=PTFnName>state</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>stateIndex</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
            throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns a state of this node.  Throws an exception if this node is a continuous
                   node that hasn't been discretized (see <A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A> for how to discretize a continuous node), or if this node does not have a state with an index of <span CLASS="paramNm">stateIndex</span>.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">stateIndex</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">the index of the state desired</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#state(java.lang.String)">state(String)</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Identical method, only uses stateName</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To discretize a continuous variable, so it may act discrete</td></tr></table><br><b>Example:</b>
  <pre CLASS="example">
  node.state(0).setName("Heads");
  node.state(1).setName("Tails");</pre></DL>
<HR>

<A NAME="state(java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype><A CLASS=APT HREF="../../norsys/netica/State.html">State</A></span>&nbsp;<span CLASS=PTFnName>state</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>stateName</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
            throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Returns a state of this node.  Throws an exception if this node is for a continuous variable and the node has not been discretized (see <A HREF="../../norsys/netica/Node.html#setLevels(double[])">setLevels</A>), or if this node does not have a state named <span CLASS="paramNm">stateName</span>.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">stateName</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">the name of the state desired</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#state(int)">state(int)</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Identical method, only uses stateIndex</td></tr></table><br><b>Example:</b>
  <pre CLASS="example">
  node.state(0).setName("Heads");
  node.state("Heads").setTitle("Coin lands with face up");</pre></DL>
<HR>

<A NAME="switchParent(int, norsys.netica.Node)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>switchParent</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>linkIndex</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;<A CLASS=APT HREF="../../norsys/netica/Node.html">Node</A></span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>newParent</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                  throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Switches the parent of the identified link with <span CLASS="paramNm">newParent</span>.<p>Makes node <span CLASS="paramNm">newParent</span> a parent of this node by replacing the existing parent at the <span CLASS="paramNm">linkIndex</span>th position, without modifying this node's equation, or any of this node's tables (such as CPT table or function table).
  <p>The new parent must be compatible with the old (e.g., same number of states), or an explanatory exception will be thrown, and no action taken.
  <p><span CLASS="reservedWord">null</span> can be passed for <span CLASS="paramNm">newParent</span>, in which case the corresponding link will not be removed, but will become disconnected.  If that link was not already named, then its name will become the name of the parent it was disconnected from.  To determine whether a link is disconnected, see <A HREF="../../norsys/netica/Node.html#getKind()">getKind</A>.
  <p>If the link was disconnected, this method may be used to re-connect it, by passing non-<span CLASS="reservedWord">null</span> for <span CLASS="paramNm">newParent</span>.
  <p>The parents of this node are numbered from 0 to one less than the number of parents, and the ordering can be obtained using <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A>.  Sometimes it is more useful to be able to pass a parent node instead of <span CLASS="paramNm">linkIndex</span>, if you know there is exactly one link from the parent node to <span CLASS="paramNm">child</span>.  This can be accomplished with the SwitchNodeParent example below.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">linkIndex</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The index of the parent Link we want to change.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm"><a href="Node.html">Node</a></span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">newParent</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The new node to be assigned to that link index.</td></tr></table><br><b>Version:</b><br><div CLASS="version">This method is available in all versions.<br>In the C Version of the API, this function is named <b>SwitchNodeParent_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getParents()">getParents</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Can be used to determine a suitable value for <span CLASS="paramNm">linkIndex</span></td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#addLink(norsys.netica.Node)">addLink</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Adds a link between two nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#deleteLink(int)">deleteLink</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Removes a link between two nodes</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getKind()">getKind</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">To determine if a link is disconnected (returns <A HREF="../../norsys/netica/Node.html#DISCONNECTED_NODE"> DISCONNECTED_NODE</A>)</td></tr></table><br><b>Example:</b>
  <pre CLASS="example">
  // Switches the link from <i>parent -&gt; child</i> to go from <i>new_parent -&gt; child</i>.
  // Assumes there is already exactly one link from parent to child.
  //
  static void switchNodeParent (Node parent, Node child, Node newParent) throws NeticaException {
      NodeList parents = child.getParents();
      int linkIndex = parents.indexOf (parent);
      child.switchParent (linkIndex, newParent);
  }</pre></DL>
<HR>

<A NAME="visual()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype><A CLASS=APT HREF="../../norsys/netica/VisualNode.html">VisualNode</A></span>&nbsp;<span CLASS=PTFnName>visual</span>&nbsp;(&nbsp;)
                  throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Return the <span CLASS="classType"> VisualNode</span> object which can be used to control the visual display of this node in Netica Application.
  <br><br><b>Version:</b><br><div CLASS="version">Versions 2.12 and later have this method.
  </div><b>Example:</b>
  <pre CLASS="example">
  node.visual().setPosition (200.0, 100.0);
  node.visual().setStyle ("belief_bars");</pre></DL>
<HR>

<A NAME="setInputDelay(int, int, java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setInputDelay</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>linkIndex</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>dimension</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>delay</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                   throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the "time" delay for a link of this dynamic Bayes net (DBN) to <span CLASS="paramNm">delay</span>.
  <p><span CLASS="paramNm">delay</span> is the length of delay as a string.  In many applications it will just be the string "1", but it can be another number, such as "0.25", or the name of a constant node, such as "dt", whose current value will be used.
  <p>The link is given by this node, <span CLASS="paramNm">linkIndex</span> in the same way as it is for <A HREF="../../norsys/netica/Node.html#setInputName(int, java.lang.String)">setInputName</A>.  <span CLASS="paramNm">linkIndex</span> corresponds to the ordering of the parents obtained by <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> (with the first parent having input_index = 0). The reason that an index number is passed instead of the actual parent, is because the link may not have a parent node (i.e., it is "disconnected"), or there may be more than 1 link from the same parent to this node.  You can find it with: <A HREF="../../norsys/netica/NodeList.html#IndexOfNodeInList(norsys.netica.Node, int)">IndexOfNodeInList</A> (parent, <A HREF="../../norsys/netica/Node.html#getParents()">getParents</A> (child)).
  <p><span CLASS="paramNm">dimension</span> must be 0 with this version of Netica.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">linkIndex</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">a parent index, the first parent having index = 0.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">dimension</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Must be 0 with this version of Netica.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">delay</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">the length of delay.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 5.02 and later have this method.<br>In the C Version of the API, this function is named <b>SetNodeInputDelay_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getInputIndex(java.lang.String)">getInputIndex</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Retrieves the index given the name (can be useful to find link_index)</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setInputName(int, java.lang.String)">setInputName</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">The name of the same link</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#getParents()">getParents</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">With IndexOfNodeInList_bn can be useful to find link_index</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setPersistance(int, java.lang.String)">setPersistance</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Sets the length of time that one node in the expanded net represents</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#expandTimeSeries(int, double, double, java.lang.String)">expandTimeSeries</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Expand the net once all delays are set</td></tr></table><br></DL>
<HR>

<A NAME="setPersistance(int, java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr valign=top><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>setPersistance</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>dimension</span>,&nbsp;</td></tr><tr><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>persistance</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                    throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD>Sets the time persistance for a node of a dynamic Bayes net (DBN), which is the maximum time it should hold its value before taking on a new one.
  <p><span CLASS="paramNm">persistance</span> is expressed as a string.  In many applications it will just be the string "1", but it can be another number, such as "0.25", or the name of a constant node, such as "period", whose current value will be used.
  <p><span CLASS="paramNm">dimension</span> must be 0 with this version of Netica.
  <p>It is usually better to first try not setting any node persistances, but rather just link delays, using <A HREF="../../norsys/netica/Node.html#setInputDelay(int, int, java.lang.String)">setInputDelay</A>.  After expanding the net with <A HREF="../../norsys/netica/Net.html#expandTimeSeries(int, double, double, java.lang.String)">expandTimeSeries</A>, if some nodes are not being given new values at a fast enough rate (i.e., they do not appear often enough in the time expansion), giving them a persistance of the desired period time will help.  Note that nodes will be repeated at a rate high enough to satisfy both link delays and node persistances, which may mean faster repititions (i.e. shorter periods) than either of these explicitly call for by themselves.
  <br><br><b>Parameters:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><span CLASS="typeNm">int</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">dimension</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Must be 0 with this version of Netica.</td></tr><tr><td VALIGN="top"><span CLASS="typeNm">String</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top"><span CLASS="paramNm">persistance</span></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">the length of time that one node in the expanded net represents.</td></tr></table><br><b>Version:</b><br><div CLASS="version">Versions 5.04 and later have this method.<br>In the C Version of the API, this function is named <b>SetNodePersistance_bn</b>.
  </div><b>See Also:</b><br><table CELLSPACING=0 CELLPADDING=0 CLASS="seeAlso"><tr><td VALIGN="top"><A HREF="../../norsys/netica/Node.html#setInputDelay(int, int, java.lang.String)">setInputDelay</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Another factor controling how often nodes are repeated in expanded net</td></tr><tr><td VALIGN="top"><A HREF="../../norsys/netica/Net.html#expandTimeSeries(int, double, double, java.lang.String)">expandTimeSeries</A></td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td VALIGN="top">Expand the net once all persistances are set</td></tr></table><br></DL>
<HR>

<A NAME="enterFinding(int)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>enterFinding</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>stateIndex</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                  throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#enterState(int)"><CODE>finding().enterState (stateIndex)</CODE></A> instead.</I>
<P>
</DL>
<HR>

<A NAME="enterFinding(java.lang.String)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>enterFinding</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;String</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>stateName</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                  throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#enterState(java.lang.String)"><CODE>finding().enterState (stateName)</CODE></A> instead.</I>
<P>
</DL>
<HR>

<A NAME="enterFindingNot(int)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>enterFindingNot</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;int</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>stateIndex</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                     throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#enterStateNot(int)"><CODE>finding().enterStateNot (stateIndex)</CODE></A> instead.</I>
<P>
</DL>
<HR>

<A NAME="enterValue(double)"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>enterValue</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;double</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>value</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#enterReal(double)"><CODE>finding().enterReal (value)</CODE></A> instead.</I>
<P>
</DL>
<HR>

<A NAME="enterLikelihood(float[])"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>enterLikelihood</span>&nbsp;(</td><td NOWRAP class=PT><table class=PTParamTable border=0 cellspacing=0 cellpadding=0><tr VALIGN=top><td NOWRAP class=PT><span CLASS=PTParamType>&nbsp;float[&nbsp;]</span></td><td NOWRAP class=PT>&nbsp;&nbsp;<span CLASS=PTParamName>likelihood</span>&nbsp;</td></tr></table></td><td NOWRAP class=PT>)
                     throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#enterLikelihood(float[])"><CODE>finding().enterLikelihood (likelihood)</CODE></A> instead.</I>
<P>
</DL>
<HR>

<A NAME="getFinding()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>int</span>&nbsp;<span CLASS=PTFnName>getFinding</span>&nbsp;(&nbsp;)
               throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#getState()"><CODE>finding().getState()</CODE></A> instead.</I>
<P>
</DL>
<HR>

<A NAME="getLikelihood()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>float[]</span>&nbsp;<span CLASS=PTFnName>getLikelihood</span>&nbsp;(&nbsp;)
                      throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#getLikelihood(float[])"><CODE>finding().getLikelihood(null)</CODE></A> instead.</I>
<P>
</DL>
<HR>

<A NAME="getValueEntered()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>double</span>&nbsp;<span CLASS=PTFnName>getValueEntered</span>&nbsp;(&nbsp;)
                       throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#getReal()"><CODE>finding().getReal()</CODE></A> instead.</I>
<P>
</DL>
<HR>

<A NAME="retractFindings()"></A><div CLASS=PT><table CLASS=PT><tr><td NOWRAP class=PT>
public&nbsp;<span CLASS=PTFntype>void</span>&nbsp;<span CLASS=PTFnName>retractFindings</span>&nbsp;(&nbsp;)
                     throws&nbsp;<A CLASS=APT HREF="../../norsys/netica/NeticaException.html">NeticaException</A></td></tr></table></div>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use <A HREF="../../norsys/netica/Value.html#clear()"><CODE>finding().clear()</CODE></A> instead.</I>
<P>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../norsys/netica/NetTester.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../norsys/netica/NodeList.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Node.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
